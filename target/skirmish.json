{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":7127516080964305838,"abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"my_characters","type":{"kind":"field"},"visibility":"private"},{"name":"their_characters","type":{"kind":"field"},"visibility":"private"},{"name":"actions","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"},{"name":"traps","type":{"kind":"field"},"visibility":"private"},{"name":"searched_traps","type":{"kind":"field"},"visibility":"private"},{"name":"move","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"map_old","type":{"kind":"array","length":10,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"map_new","type":{"kind":"array","length":10,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"received_events","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"public"},{"name":"sending_events","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"public"},{"name":"gamestate_before_hash","type":{"kind":"field"},"visibility":"public"},{"name":"gamestate_after_hash","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"actions":[{"start":3,"end":8}],"gamestate_after_hash":[{"start":668,"end":669}],"gamestate_before_hash":[{"start":667,"end":668}],"map_new":[{"start":331,"end":651}],"map_old":[{"start":11,"end":331}],"move":[{"start":10,"end":11}],"my_characters":[{"start":1,"end":2}],"received_events":[{"start":651,"end":659}],"searched_traps":[{"start":9,"end":10}],"secret":[{"start":0,"end":1}],"sending_events":[{"start":659,"end":667}],"their_characters":[{"start":2,"end":3}],"traps":[{"start":8,"end":9}]},"return_type":null,"return_witnesses":[],"error_types":{"2101831866778210340":{"error_kind":"fmtstring","length":33,"item_types":[{"kind":"field"},{"kind":"field"}]}}},"bytecode":"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Xp7cuvvP63RuVyHyMrn1wOT1/7n1ROXlfisEl5fVsxfuPjWynKPje9vRlDu+t53mie9tp33ie9tpn/jedjp5x/e20zzxve20T3xvO52843vbacsd39tOm3d8bzttueN72ynxve1on/jednxvmz/xve3ocovvbUeXW3xvO7rc4nvb0eUW39uO7gl5nqDvbY+J721HU+743naaJ763nfaJ722nfeJ72+nkHd/bTvPE97bTPvG97XTyju9tpy13fG87bd7xve205Y7vbafE97ajfeJ72/G9bf7E97ajyy2+tx1dbvG97ehyi+9tR5dbfG87uifkeYK+tz02vrcdTbnje9tpnvjedtonvred9onvbaeTd3xvO80T39tO+8T3ttPJO763nbbc8b3ttHnH97bTlju+t50S39uO9onvbcf3tvkT39uOLrf43nZ0ucX3tqPLLb63HV1u8b3t6J6Q5wn63va4+N52NOWO722neeJ722mf+N522ie+t51O3vG97TRPfG877RPf204n7/jedtpyx/e20+Yd39tOW+743nZKfG872ie+tx3f2+ZPfG87utzie9vR5Rbf244ut/jednS5xfe2o3tCnifoe9vj43vb0ZQ7vred5onvbad94nvbaZ/43nY6ecf3ttM88b3ttE98bzudvON722nLHd/bTpt3fG87bbnje9sp8b3taJ/43nZ8b5s/8b3t6HKL721Hl1t8bzu63OJ729HlFt/bju4JeZ6g721PiO9tR1Pu+N52mie+t532ie9tp33ie9vp5B3f207zxPe20z7xve108o7vbactd3xvO23e8b3ttOWO722nxPe2o33ie9vxvW3+xPe2o8stvrcdXW7xve3ocovvbUeXW3xvO7on5HmCvrd9a3xvO5pyx/e20zzxve20T3xvO+0T39tOJ+/43naaJ763nfaJ722nk3d8bzttueN722nzju9tpy13fG87Jb63He0T39uO723zJ763HV1u8b3t6HKL721Hl1t8bzu63OJ729E9Ic8T9L3t2+J729GUO763neaJ722nfeJ722mf+N52OnnH97bTPPG97bRPfG87nbzje9tpyx3f206bd3xvO22543vbKfG97Wif+N52fG+bP/G97ehyi+9tR5dbfG87utzie9vR5Rbf247uCXmeoO9tT4zvbUdT7vjedponvred9onvbad94nvb6eQd39tO88T3ttM+8b3tdPKO722nLXd8bztt3vG97bTlju9tp8T3tqN94nvb8b1t/sT3tqPLLb63HV1u8b3t6HKL721Hl1t8bzu6J+R5gr63PSm+tx1NueN722me+N522ie+t532ie9tp5N3fG87zRPf2077xPe208k7vredttzxve20ecf3ttOWO763nRLf2472ie9tx/e2+RPf244ut/jednS5xfe2o8stvrcdXW7xve3onpDnCfre9uT43nY05Y7vbad54nvbaZ/43nbaJ763nU7e8b3tNE98bzvtE9/bTifv+N522nLH97bT5h3f205b7vjedkp8bzvaJ763Hd/b5k98bzu63OJ729HlFt/bji63+N52dLnF97aje0KeJ+h721Pie9vRlDu+t53mie9tp33ie9tpn/jedjp5x/e20zzxve20T3xvO52843vbacsd39tOm3d8bzttueN72ynxve1on/jednxvmz/xve3ocovvbUeXW3xvO7rc4nvb0eUW39uO7gl5nqDvbU+N721HU+743naaJ763nfaJ722nfeJ72+nkHd/bTvPE97bTPvG97XTyju9tpy13fG87bd7xve205Y7vbafE97ajfeJ72/G9bf7E97ajyy2+tx1dbvG97ehyi+9tR5dbfG87uifkeYK+tz0tvrcdTbnje9tpnvjedtonvred9onvbaeTd3xvO80T39tO+8T3ttPJO763nbbc8b3ttHnH97bTlju+t50S39uO9onvbcf3tvkT39uOLrf43nZ0ucX3tqPLLb63HV1u8b3t6J6Q5wn63vb0+N52NOWO722neeJ722mf+N522ie+t51O3vG97TRPfG877RPf204n7/jedtpyx/e20+Yd39tOW+743nZKfG872ie+tx3f2+ZPfG87utzie9vR5Rbf244ut/jednS5xfe2o3tCnifoe9v3JP6vrOVM2nvEiH6Dho4oO2JI2ZtH9hkxvPf1I8qOGjDihrJDbuk3PHXgkFHu/+i+s//hoJEDRwwYOnBM2j98MNY/fNjzhyXT/mHvvn3T/k32zDH+WM5Y/zA5c/SlzBPrj+WL4ccWxfpjS2L9w2UxlHJFrD+2KoYf65glxh/rHOsfds0SfSmviPXHrozhxw7E+mOHYv3DwzGU8misP/ZPDD/2QNYYf+yhWP/wkazRl/KxWH/siRh+rEFSjD/WKNY/bJIUfSmbxfpjLWL4sa9i/bFvYv3DXTGUck+sP/ZtDD92a7YYf2xirH84OVv0pZwa649Nj+HHymWP8ccqxPqHlbJHX8oqsf5YtRh+7J1Yf2xDrH/4fgyl/CDWH/sohh+7JUeMPzYmR/Q/9mgMf/N4rAWcG+sfzouhlOtj+Ju3Yy3gu7H+4XsxlPKHGP7mp1gL+Eusf/hbDKXMkzP6v8mXM8YCFoj1DwvFUMp6MfxNg1gL2CjWP2wSQyl7xfA318ZawN6x/uH1MZRyagx/Mz3WAs6I9Q9nxlDKF2P4m8WxFnBprH+4PIZSborhb76ItYBfxvqH22Io5d8x/M2xWAt4PNY/PBlDKcvmiv5vyueKsYAVY/3DyjGU8uIY/qZdrAW8JNY/7BBDKQfH8DdDYy3g8Fj/cEQMpdwb64/ti+HHsiZH/zfZkmMsYI5Y/zBXDKWsEcPf1Iy1gE6sf1g7hlJeHsPfdIu1gN1j/cMeMZRyXAx/MyHWAt4W6x9OiqGUT8XwNwtjLeAzsf7hczGUcmMMf/NhrAX8ONY//DSGUv4Rw98ciLWAh2L9w8MxlLJI7uj/pljuGAtYItY/LBVDKZvF8DctYi1gq1j/8MIYStkvhr/pH2sBB8T6hzfFUMpZMfzNnFgLeHesf3hvDKVcGcPfrI61gGti/cO1MZRyRwx/83WsBdwZ6x/ujraU4Sh+OLbiCU6GEkKRD7fDpXP/+0zGzuT57zN5/iYx9L+ahNj/PpMn/3Kev0nvf5PpDPnkTKec+dL578Jhtazp5BF+snn+9ydC2HNA4bM1WdIpW2bP/z+rpyyZ8GWJ+HcIiaG0bZAvnfaJlZEcofQZyRFKy0iOdH6XM5IjdG5G0ssno4zEWs/sofTrmT2Utp7Z0ykfr2f20LnrmV4+Ga3n/wE6kXI1SvcQAA==","debug_symbols":"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","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"46":{"source":"use crate::game::Game;\nuse crate::character::Character;\nuse crate::EVENT_COUNT;\nuse crate::NO_EVENT;\nuse crate::SEE_MOVE;\nuse crate::SEE_RITUAL;\nuse crate::SEE_CAST;\nuse crate::SEE_DRAW;\nuse crate::SEE_SEARCH_TRAP;\nuse crate::RECEIVE_ATTACK;\nuse crate::TRIGGERED_TRAP;\nuse crate::WIN;\nuse crate::FOUND_TRAP;\nuse crate::SEE_CHARS;\nuse crate::RECEIVE_DAMAGE;\nuse crate::DESTROY;\nuse crate::DEATH;\nuse crate::MAX_TRAPS;\nuse crate::map::Map;\nuse crate::trap::Trap;\nuse crate::WALL;\nuse crate::EMPTY;\nuse crate::ATTACK_FIREBALL;\nuse crate::Result;\nuse crate::TRAPS_BUFFER_MASK;\nuse dep::std;\n\n// trait Event {\n//     fn to_field(self) -> Field;\n//     fn process<T, U>(self, game: &mut T) where U: Character, T: Game<U>;\n// }\n\nstruct Event {\n    event: u8,\n    actor_id: u8,\n    subtype: u8,\n    x: u8,\n    y: u8,\n    value: u8,\n}\n\nfn handle_see_move(game: &mut Game, actor_id: u8, x: u8, y: u8) -> bool {\n    //assert(actor_id < 5);\n    // let actor_result = game.get_their_char(actor_id);\n    // assert(actor_result.success);\n    true\n    // let mut result = false;\n    // if actor_id < 5 {\n    //     let mut actor_result = game.get_their_char(actor_id);\n    //     if actor_result.success {\n    //         let mut actor = actor_result.value;\n    //         let is_neighbor_result = Map::is_neighbor(actor.get_x(), actor.get_y(), x, y);\n    //         if is_neighbor_result.success {\n    //             if is_neighbor_result.value {\n    //                 let can_move_to = game.map.can_move_to(x, y);\n    //                 if can_move_to.success & can_move_to.value {\n    //                     result = actor.set_pos(x, y);\n    //                     //result = true;\n    //                 }\n    //             }\n    //         }\n    //     }\n    // }\n    // result\n}\n\n#[test]\nfn test_handle_see_move() {\n    let mut game = crate::game::get_test_game();\n    let their_char = game.get_their_char(0).value;\n    assert(their_char.get_x() == 22);\n    assert(their_char.get_y() == 2);\n    let result = handle_see_move(&mut game, 0, 21, 2);\n    assert(result == true);\n}\n\n#[test]\nfn test_handle_see_move_fail() {\n    let mut game = crate::game::get_test_game();\n    let result = handle_see_move(&mut game, 5, 1, 2);\n    assert(result == false);\n    let result2 = handle_see_move(&mut game, 0, 1, 2);\n    assert(result2 == false);\n}\n\nfn get_accumulated_trap_damage(game: &mut Game, x: u8, y: u8) -> u8 {\n    let mut dmg = 0 as u8;\n    let mut traps_count = game.get_trap_count();\n    for i in 0..MAX_TRAPS {\n        let mut trap_result = game.get_trap(i);\n        if i < traps_count {\n            let mut trap = trap_result.value;\n            if (trap.x == x) & (trap.y == y) & (*trap.sprung == 0) {\n                *trap.sprung = 1;\n                dmg += trap.damage;\n            }\n        }\n    }\n    dmg\n}\n\nfn handle_see_progress(game: &mut Game, actor_id: u8, value: u8) -> bool {\n    let mut result = false;\n    if actor_id < 5 {\n        let mut actor_result = Game::get_their_char(*game, actor_id);\n        if actor_result.success {\n            let mut actor = actor_result.value;\n            if (actor.get_status() == 0) | (actor.get_status() + 1 == value) {\n                result = actor.set_status(actor.status + 1);\n            }\n        }\n    }\n    result\n}\n\n#[test]\nfn test_handle_see_progress() {\n    let mut game = crate::game::get_test_game();\n    let result = handle_see_progress(&mut game, 0, 1);\n    assert(result == true);\n}\n\n#[test]\nfn test_handle_see_progress_fail() {\n    let mut game = crate::game::get_test_game();\n    let result = handle_see_progress(&mut game, 5, 1);\n    assert(result == false);\n    let result2 = handle_see_progress(&mut game, 0, 1);\n    assert(result2 == true);\n    let result3 = handle_see_progress(&mut game, 0, 3);\n    assert(result3 == false);\n}\n\n/**\n    * @dev Handles the SEE_SEARCH_TRAP event.\n    * @param game The game instance.\n    * @param actor_id The id of the actor.\n    * @param x The x coordinate of the search location.\n    * @param y The y coordinate of the search location.\n    * @return Event != 0 if the event was successfully processed and a trap was found, 0 otherwise.\n    */\nfn handle_see_search_trap(game: Game, actor_id: u8, x: u8, y: u8) -> Field {\n    let actor_result = game.get_their_char(actor_id);\n    let is_neighbor_result = Map::is_neighbor(actor_result.value.get_x(), actor_result.value.get_y(), x, y);\n\n    let mut found = false;\n    let mut success = actor_result.success & is_neighbor_result.success;\n    let mut event: Field = 0;\n    for i in 0..MAX_TRAPS {\n        let trap_result = game.get_trap(i);\n        success &= trap_result.success;\n        if success & !found {\n            if (trap_result.value.x == x) & (trap_result.value.y == y) {\n                found = true;\n                event = build_std_event(FOUND_TRAP, actor_id, x, y);\n            }\n        }\n    }\n    event\n    // if found {\n    //     success &= game.add_event(event);\n    // }\n    //success & game.add_event(event)\n    // let mut result = false;\n    // let traps_count = (*game).get_trap_count() as u8;\n    // if actor_id < 5 {\n    //     let mut actor_result = (*game).get_their_char(actor_id);\n    //     if actor_result.success {\n    //         let actor = actor_result.value;\n    //         let is_neighbor_result = Map::is_neighbor(*actor, x, y);\n    //         if is_neighbor_result.success {\n    //             if is_neighbor_result.value {\n    //                 let mut found = false;\n    //                 for j in 0..10 {\n    //                     if (j < traps_count & !found) {\n    //                         let trap = (*game).get_trap(j);\n    //                         //let k = _handle_see_search_trap(*game, j, x, y);\n    //                         // if found {\n    //                         //     result = game.add_event(0); //build_std_event(FOUND_TRAP, actor_id, x, y));\n    //                         // }\n    //                         //found = _handle_see_search_trap(*game, j, x, y);\n    //                         result = true;\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    // }\n    // result\n}\n\n#[test]\nfn test_handle_see_search_trap() {\n    let mut game = crate::game::get_test_game();\n    assert(game.add_my_trap(Trap { x: 1, y: 2, sprung: &mut 0, damage: 64 }));\n    let result = handle_see_search_trap(game, 0, 1, 2);\n    assert(result != 0);\n    \n    let not_found = handle_see_search_trap(game, 0, 2, 2);\n    assert(not_found == 0);\n}\n\nfn handle_receive_attack(my_chars: [&mut Character; 5], map: &mut Map, x: u8, y: u8, dmg: u8, subtype: u8) -> Result<[Field; 8]> {\n    let mut success = true;\n    let mut event_counter = 0;\n    let mut result: [Field; 8] = [0; 8];\n    let splash_dmg: u8 = dmg >> 1;\n    for j in 0..5 {\n        // let my_char_result = game.get_my_char(j);\n        // success &= my_char_result.success;\n        // let my_char = my_char_result.value;\n        let my_char = my_chars[j];\n\n        if (my_char.get_x() == x) & (my_char.get_y() == y) { /////////////events and actions: rethink the be/le stuff!\n            //if !Character::set_status(my_char, 0) { false }\n            // if dmg >= my_char.get_health() {\n            //     //if !Character::set_health(my_char, 0) { false }\n            //     //let add_event_result = game.add_event(build_std_event(DEATH, j, self.x, self.y));\n            //     //if !add_event_result { false }\n            //     result[event_counter & 7] = build_std_event(DEATH, j, x, y);\n            //     event_counter += 1;\n            // } else {\n                // if !Character::set_health(my_char, my_char.get_health() - self.value) { false }\n                // let add_event_result = game.add_event(build_value_event(RECEIVE_DAMAGE, j, self.x, self.y, self.value));\n                // if !add_event_result { false }\n                success &= my_char.set_status(0);\n                if dmg >= my_char.get_health() {\n                    success &= my_char.set_health(0);\n                    result[event_counter & 7] = build_std_event(DEATH, j, x, y);\n                } else {\n                    success &= my_char.set_health(my_char.get_health() - dmg);\n                    result[event_counter & 7] = build_value_event(RECEIVE_DAMAGE, j, x, y, dmg);\n                }\n                event_counter += 1;\n            // }\n        } else {\n            if subtype == ATTACK_FIREBALL {\n                let is_neighbor_result = Map::is_neighbor(my_char.get_x(), my_char.get_y(), x, y);\n                success &= is_neighbor_result.success;\n                if is_neighbor_result.value {\n                    success &= my_char.set_status(0);\n                    if splash_dmg >= my_char.get_health() {\n                        success &= my_char.set_health(0);\n                        result[event_counter & 7] = build_std_event(DEATH, j, my_char.get_x(), my_char.get_y());\n                    } else {\n                        success &= my_char.set_health(my_char.get_health() - splash_dmg);\n                        result[event_counter & 7] = build_value_event(RECEIVE_DAMAGE, j, my_char.get_x(), my_char.get_y(), splash_dmg);\n                    }\n                    // if splash_dmg >= my_char.get_health() {\n                    //     // if !Character::set_health(my_char, 0) { false }\n                    //     // let add_event_result = game.add_event(build_std_event(DEATH, j, x, y));\n                    //     // if !add_event_result { false }\n                    //     result[event_counter & 7] = build_std_event(DEATH, j, my_char.get_x(), my_char.get_y());\n                    //     event_counter += 1;\n                    // } else {\n                        // if !Character::set_health(my_char, my_char.get_health() - splash_dmg) { false }\n                        // let add_event_result = game.add_event(build_value_event(RECEIVE_DAMAGE, j, self.x, self.y, splash_dmg));\n                        // if !add_event_result { false }\n                        // result[event_counter & 7] = build_value_event(RECEIVE_DAMAGE, j, my_char.get_x(), my_char.get_y(), splash_dmg);\n                        event_counter += 1;\n                    // }\n                }\n            }\n        }\n    }\n\n    let tile_result = map.get(x, y);\n    success &= tile_result.success;\n    if tile_result.value == WALL {\n        //if !game.set_tile(self.x, self.y, EMPTY) { false }\n        //if !game.add_event(build_std_event(DESTROY, tile, self.x, self.y)) { false }\n        result[event_counter & 7] = build_std_event(DESTROY, tile_result.value, x, y);\n    }\n    Result {\n        success: success,\n        value: result\n    }\n}\n\n#[test]\nfn test_handle_receive_attack() {\n    let mut game = crate::game::get_test_game();\n    let mut my_chars = crate::game::get_test_my_chars();\n    let char1 = my_chars[0]; //game.get_my_char(0).value;\n    let char2 = my_chars[1]; //game.get_my_char(1).value;\n    let char3 = my_chars[2]; //game.get_my_char(2).value;\n\n    let result = handle_receive_attack(my_chars, game.map, char2.get_x(), char2.get_y(), 128, ATTACK_FIREBALL);\n    assert(result.success == true);\n    let ev0 = result.value[0];\n    let ev0_should = build_value_event(RECEIVE_DAMAGE, 0, char1.get_x(), char1.get_y(), 64);\n    assert(ev0 == ev0_should, f\"event 0: {ev0} != {ev0_should}\");\n    let ev1 = result.value[1];\n    let ev1_should = build_std_event(DEATH, 1, char2.get_x(), char2.get_y());\n    assert(ev1 == ev1_should, f\"event 1: {ev1} != {ev1_should}\");\n    let ev2 = result.value[2];\n    let ev2_should = build_value_event(RECEIVE_DAMAGE, 2, char3.get_x(), char3.get_y(), 64);\n    assert(ev2 == ev2_should, f\"event 2: {ev2} != {ev2_should}\");\n    assert(result.value[3] == 0);\n    assert(result.value[4] == 0);\n    assert(result.value[5] == 0);\n    assert(result.value[6] == 0);\n    assert(result.value[7] == 0);\n}\n\n// TODO: handle multiple traps on the same field!\nfn handle_trigger_trap(game: &mut Game, my_char: &mut Character, x: u8, y: u8, value: u8) -> Result<Field> {\n    // let my_char_result = game.get_my_char(actor_id);\n    // //if !my_char_result.success { false }\n    let mut success = true; //my_char_result.success;\n    // let my_char = my_char_result.value;\n    let mut found: u8 = 0;\n    let mut not_found: u8 = 1;\n\n    let traps_count = game.get_their_trap_count();\n    for j in 0..MAX_TRAPS {\n        let mut trap_result = game.get_their_trap(j);\n        if j < traps_count {\n            success &= trap_result.success;\n            // if !trap_result.success { false }\n            let mut trap = trap_result.value;\n\n            if (trap.x == x) & (trap.y == y) & (*trap.sprung == 0) {\n                *trap.sprung = 1;\n                found = 1;\n                not_found = 0;\n                // if !my_char.set_status(0) { false }\n                // if value >= my_char.get_health() {\n                //     if !my_char.set_health(0) { false }\n                //     game.add_event(build_std_event(DEATH, my_char.get_id(), x, y))\n                // } else {\n                //     if !my_char.set_health(my_char.get_health() - value) { false }\n                //     game.add_event(build_value_event(RECEIVE_DAMAGE, my_char.get_id(), x, y, value))\n                // }\n            }\n        }\n    }\n    let searched_trap_count = game.searched_trap_count;\n    let next_trap_pos = TRAPS_BUFFER_MASK & searched_trap_count;\n    let old_trap = game.searched_traps[next_trap_pos];\n    let mut sprung = not_found | (*old_trap.sprung & found);\n    let perhaps_missing_trap = Trap {\n        x: (x * not_found) | (old_trap.x * found),\n        y: (y * not_found) | (old_trap.y * found),\n        sprung: &mut sprung,\n        damage: (value * not_found) | (old_trap.damage * found),\n    };\n    game.searched_traps[next_trap_pos] = perhaps_missing_trap;\n    (*game).searched_trap_count = searched_trap_count + not_found as u64;\n\n    // if !found {\n    //     perhaps_missing_trap.x = x;\n    //     perhaps_missing_trap.y = y;\n    //     //*perhaps_missing_trap.sprung = 1;\n    //     perhaps_missing_trap.damage = value;\n    //     //*game.searched_trap_count = searched_trap_count + 1;\n    // }\n    //game.searched_traps[next_trap_pos] = perhaps_missing_trap;\n    //     assert(MAX_TRAPS <= TRAPS_BUFFER_SIZE);\n    //     let tc = *self.searched_trap_count;\n    //     self.searched_traps[tc & TRAPS_BUFFER_MASK] = trap;\n    //     *self.searched_trap_count = tc + 1;\n    //     tc < MAX_TRAPS\n    // let mut perhaps_missing_trap = Trap { x: x, y: y, sprung: &mut 1, damage: value };\n    // if !found {\n    //     success &= game.add_their_trap(perhaps_missing_trap);\n    // }\n\n    success &= (found == 1) | (searched_trap_count < MAX_TRAPS);\n    success &= my_char.set_status(0);\n    if value >= my_char.get_health() {\n        //success &= my_char.set_health(0);\n        //game.add_event(build_std_event(DEATH, my_char.get_id(), x, y))\n        Result {\n            success: success,\n            value: build_std_event(DEATH, my_char.get_id(), x, y)\n        }\n    } else {\n        success &= my_char.set_health(my_char.get_health() - value);\n        if my_char.get_has_been_seen() == 1 {\n            //game.add_event(build_value_event(RECEIVE_DAMAGE, my_char.get_id(), x, y, value))\n            Result {\n                success: success,\n                value: build_value_event(RECEIVE_DAMAGE, my_char.get_id(), x, y, value)\n            }\n        } else {\n            Result {\n                success: success,\n                value: 0\n            }\n        }\n    }\n}\n\n#[test]\nfn test_handle_trigger_trap() {\n    let mut game = crate::game::get_test_game();\n    let mut char2 = crate::character::get_test_my_character(1, 2, 3, 4); // game.get_my_char(1).value;\n\n    let result = handle_trigger_trap(&mut game, &mut char2, char2.get_x(), char2.get_y(), 32);\n    assert(result.success == true);\n    assert(result.value == 0); // we have not been spotted yet!\n    assert(char2.get_health() == 68);\n\n    assert(char2.set_has_been_seen(1));\n    let result2 = handle_trigger_trap(&mut game, &mut char2, char2.get_x(), char2.get_y(), 32);\n    assert(result2.success == true);\n    assert(result2.value == build_value_event(RECEIVE_DAMAGE, 1, char2.get_x(), char2.get_y(), 32));\n    assert(char2.get_health() == 36);\n\n    let result3 = handle_trigger_trap(&mut game, &mut char2, char2.get_x(), char2.get_y(), 64);\n    let ev0 = result3.value;\n    let ev0_should = build_std_event(DEATH, 1, char2.get_x(), char2.get_y());\n    assert(ev0 == ev0_should, f\"event 3: {ev0} != {ev0_should}\");\n}\n\nimpl Event {\n    fn to_field(self) -> Field {\n        build_std_event(self.event, self.actor_id, self.x, self.y)\n    }\n\n    fn process(self, game: &mut Game) -> bool {\n        let mut result = true;\n        if self.event >= EVENT_COUNT { result = false; }\n        if self.event == NO_EVENT {\n            result = true;\n        }\n        if self.event == SEE_MOVE {\n            assert(self.actor_id < 5);\n            // let actor_result = game.get_their_char(self.actor_id);\n            // assert(actor_result.success);\n        // let mut result = false;\n        // if actor_id < 5 {\n        //     let mut actor_result = game.get_their_char(actor_id);\n        //     if actor_result.success {\n        //         let mut actor = actor_result.value;\n        //         let is_neighbor_result = Map::is_neighbor(actor.get_x(), actor.get_y(), x, y);\n        //         if is_neighbor_result.success {\n        //             if is_neighbor_result.value {\n        //                 let can_move_to = game.map.can_move_to(x, y);\n        //                 if can_move_to.success & can_move_to.value {\n        //                     result = actor.set_pos(x, y);\n        //                     //result = true;\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // result\n            //assert(game.handle_see_move(self.actor_id, self.x, self.y));\n            // let trap_dmg = get_accumulated_trap_damage(game, self.x, self.y);\n            // if trap_dmg > 0 {\n            //     result &= game.add_event(build_value_event(TRIGGERED_TRAP, self.actor_id, self.x, self.y, trap_dmg));\n            // }\n        }\n        // if (self.event == SEE_RITUAL) | (self.event == SEE_CAST) | (self.event == SEE_DRAW) {\n        //     result &= handle_see_progress(game, self.actor_id, self.value);\n        // }\n        // if self.event == SEE_SEARCH_TRAP {\n        //     let result_event = handle_see_search_trap(*game, self.actor_id, self.x, self.y);\n        //     if result_event != 0 {\n        //         result &= game.add_event(result_event);\n        //     }\n        // }\n        // if self.event == RECEIVE_ATTACK {\n        //     let result_event = handle_receive_attack(game.my_chars, game.map, self.x, self.y, self.value, self.subtype);\n        //     if result_event.success {\n        //         for i in 0..8 {\n        //             if result_event.value[i] != 0 {\n        //                 result &= game.add_event(result_event.value[i]);\n        //             }\n        //         }\n        //     } else {\n        //         result = false;\n        //     }\n        // }\n        // if self.event == TRIGGERED_TRAP { // actor_id = my_char when receive\n        //     let result_event = handle_trigger_trap(game, game.my_chars[self.actor_id], self.x, self.y, self.value);\n        //     if result_event.success {\n        //         result &= game.add_event(result_event.value);\n        //     } else {\n        //         result = false;\n        //     }\n        // }\n        // if self.event == WIN {\n        //     for i in 0..5 {\n        //         // let my_char_result = Game::get_my_char(*game, i);\n        //         // if !my_char_result.success { false }\n        //         // let my_char = my_char_result.value;\n        //         let my_char = game.my_chars[i];\n\n        //         if (my_char.get_health() > 0) {\n        //             false //the other one cheated, I did not lose, I still got alive characters!\n        //         }\n        //     }\n        //     result &= game.lose();\n        // }\n        // if self.event == FOUND_TRAP { // actor_id = my_char when receive\n        //     result &= game.add_their_trap(Trap { x: self.x, y: self.y, sprung: &mut 0, damage: self.value });\n        // }\n        // if self.event == SEE_CHARS { // actor_id = their_char when receive, got health & class\n        //     let their_char_result = game.get_their_char(self.actor_id);\n        //     result = their_char_result.success;\n        //     let their_char = their_char_result.value;\n\n        //     result &= their_char.get_has_been_seen() == 0;\n        //     result &= their_char.set_health(self.value);\n        //     result &= their_char.set_class(self.subtype);\n        // }\n        // if self.event == RECEIVE_DAMAGE { // actor_id = their_char when receive\n        //     let their_char_result = game.get_their_char(self.actor_id);\n        //     let their_health = their_char_result.value.get_health();\n\n        //     if their_health <= self.value {\n        //         result = false; // something is off\n        //     } else {\n        //         result = their_char_result.success & their_char_result.value.set_health(their_health - self.value);\n        //     }\n        // }\n        // if self.event == DESTROY { // actor_id = tile\n        //     result = game.set_tile(self.x, self.y, EMPTY);\n        // }\n        // if self.event == DEATH { // actor_id = their_char when receive\n        //     let their_char_result = game.get_their_char(self.actor_id);\n        //     result = their_char_result.success & their_char_result.value.set_health(0);\n        // }\n        result\n    }\n}\n\npub fn build_std_event(event: u8, actor_id: u8, x: u8, y: u8) -> Field {\n    std::field::bytes32_to_field([\n        0, event, actor_id, x, y, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ])\n}\n\npub fn build_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8) -> Field {\n    std::field::bytes32_to_field([\n        0, event, actor_id, x, y, value, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ])\n}\n\npub fn build_subtype_value_event(event: u8, actor_id: u8, x: u8, y: u8, value: u8, subtype: u8) -> Field {\n    std::field::bytes32_to_field([\n        0, event, actor_id, x, y, value, subtype, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    ])\n}\n\npub fn parse_event(event: Field) -> Event {\n    let split = event.to_be_bytes(32);\n    Event {\n        event: split[1],\n        actor_id: split[2],\n        x: split[3],\n        y: split[4],\n        value: split[5],\n        subtype: split[6],\n    }\n}\n\n#[test]\nfn test_build_std_event() {\n    let event = build_std_event(SEE_MOVE, 1, 2, 3);\n    let parsed = parse_event(event);\n    assert(parsed.event == SEE_MOVE);\n    assert(parsed.actor_id == 1);\n    assert(parsed.x == 2);\n    assert(parsed.y == 3);\n}\n\n#[test]\nfn test_build_value_event() {\n    let event = build_value_event(RECEIVE_DAMAGE, 1, 2, 3, 4);\n    let parsed = parse_event(event);\n    assert(parsed.event == RECEIVE_DAMAGE);\n    assert(parsed.actor_id == 1);\n    assert(parsed.x == 2);\n    assert(parsed.y == 3);\n    assert(parsed.value == 4);\n}\n\n#[test]\nfn test_build_subtype_value_event() {\n    let event = build_subtype_value_event(SEE_CAST, 1, 2, 3, 4, 5);\n    let parsed = parse_event(event);\n    assert(parsed.event == SEE_CAST);\n    assert(parsed.actor_id == 1);\n    assert(parsed.x == 2);\n    assert(parsed.y == 3);\n    assert(parsed.value == 4);\n    assert(parsed.subtype == 5);\n}\n\n#[test]\nfn test_event_no_event() {\n    let mut game = crate::game::get_test_game();\n    //let my_chars = crate::game::get_test_my_chars();\n    let event = Event {\n        event: NO_EVENT,\n        actor_id: 0,\n        x: 0,\n        y: 0,\n        value: 0,\n        subtype: 0,\n    };\n    assert(event.event == NO_EVENT);\n    let result = event.process(&mut game);\n    assert(result == true);\n}","path":"/home/andreas/git_repositories/noir/skirmish/src/event.nr"},"47":{"source":"use crate::HEIGHT;\nuse crate::WIDTH;\nuse crate::NON_EMPTY_WALKABLE_TILE_MIN;\nuse crate::Result;\nuse crate::TILE_COUNT;\nuse crate::WALL;\nuse crate::WATER;\nuse crate::EMPTY;\nuse crate::UNKNOWN_CLASS_TILE;\nuse crate::UNKNOWN_CLASS;\nuse crate::character::Character;\nuse crate::TRAP;\nuse crate::TRAP_USED;\nuse crate::TRAP_FOUND;\nuse crate::MAX_TRAPS;\nuse crate::TRAPS_BUFFER_SIZE;\nuse crate::trap::Trap;\nuse crate::character::get_test_my_character;\nuse crate::character::get_test_their_character;\nuse crate::ROGUE;\nuse crate::KNIGHT;\nuse crate::MAGE;\nuse crate::RITUALIST;\nuse crate::ARCHER;\n\nstruct Map {\n    _data: [[&mut u8; WIDTH]; 16],\n}\n\nimpl Map {\n    pub fn build(data: [[u8; WIDTH]; HEIGHT]) -> Result<Map> {\n        let mut d = [[&mut 0; WIDTH]; 16];\n        let mut success = true;\n\n        for y in 0..HEIGHT {\n            for x in 0..WIDTH {\n                let tile = data[y][x];  \n                if tile >= TILE_COUNT {\n                    success = false;\n                };\n                *d[y][x] = tile;\n            }\n        }\n        Result {\n            value: Map {\n                _data: d\n            },\n            success: success,\n        }\n    }\n\n    /**\n     * Get the tile at the given coordinates.\n     * \n     * @param x The x coordinate.\n     * @param y The y coordinate.\n     * @return The tile at the given coordinates.\n     */\n    pub fn get(self, x: u8, y: u8) -> Result<u8> {\n        Result {\n            value: *self._data[y & 15][x & 31],\n            success: (y < HEIGHT) & (x < WIDTH),\n        }\n        // if (y >= HEIGHT) | (x >= WIDTH) {\n        //     Result {\n        //         value: 0,\n        //         success: false\n        //     }\n        // } else {\n        //     Result {\n        //         value: *self._data[y][x],\n        //         success: true\n        //     }\n        // }\n    }\n\n    pub fn set(mut self, x: u8, y: u8, value: u8) -> bool {\n        *self._data[y & 15][x & 31] = value;\n        (y < HEIGHT) & (x < WIDTH) & (value < TILE_COUNT)\n        // if (y >= HEIGHT) | (x >= WIDTH) | value >= TILE_COUNT {\n        //     false\n        // } else {\n        //     *self._data[y][x] = value;\n        //     true\n        // }\n    }\n\n    pub fn can_move_to(self, x: u8, y: u8) -> Result<bool> {\n        let tile = *self._data[y & 15][x & 31];\n        Result {\n            value: (y < HEIGHT) & (x < WIDTH) & (tile == 0) | (tile >= NON_EMPTY_WALKABLE_TILE_MIN),\n            success: (y < HEIGHT) & (x < WIDTH),\n        }\n        // if (y >= HEIGHT) | (x >= WIDTH) {\n        //     Result {\n        //         value: false,\n        //         success: false\n        //     }\n        // } else {\n        //     let tile_result = self.get(x, y);\n        //     if !tile_result.success {\n        //         Result {\n        //             value: false,\n        //             success: false\n        //         }\n        //     }\n        //     let tile = tile_result.value;\n        //     if (tile == 0) | (tile >= NON_EMPTY_WALKABLE_TILE_MIN) {\n        //         Result {\n        //             value: true,\n        //             success: true\n        //         }\n        //     } else {\n        //         Result {\n        //             value: false,\n        //             success: true\n        //         }\n        //     }\n        // }\n    }\n\n    pub fn is_neighbor(curr_x: u8, curr_y: u8, x: u8, y: u8) -> Result<bool> {\n        // let curr_x = actor.get_x();\n        // let curr_y = actor.get_y();\n        let success = (curr_x < WIDTH) & (curr_y < HEIGHT) & (x < WIDTH) & (y < HEIGHT); // & ((curr_x == x) | (curr_y == y)); // & ((actor.get_x() != x) | (actor.get_y() != y));\n\n        if curr_x == x {\n            if (curr_y == 0) {\n                Result { success: success, value: y <= 1 }\n            } else {\n                Result { success: success, value: (y >= curr_y - 1) & (y <= curr_y + 1) }\n            }\n        } else {\n            if (curr_x == 0) {\n                Result { success: success, value: x <= 1 }\n            } else {\n                Result { success: success, value: (x >= curr_x - 1) & (x <= curr_x + 1) }\n            }\n        }\n    }\n}\n\npub fn get_test_map(my_chars: [Character; 5], their_chars: [Character; 5], my_traps: [Trap; TRAPS_BUFFER_SIZE], their_traps: [Trap; TRAPS_BUFFER_SIZE]) -> &mut Map {\n    let mut map_result = Map::build([\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [WALL, WALL, EMPTY,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [WALL, EMPTY,EMPTY,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, EMPTY,EMPTY,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, WALL, EMPTY,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n    ]);\n\n    // let my_trap_tiles = [TRAP, TRAP_USED];\n    // for i in 0..MAX_TRAPS {\n    //     let my_trap = my_traps[i];\n    //     // let tile = TRAP; //if my_trap.sprung == 1 { TRAP_USED } else { TRAP };\n    //     let old_tile = map_result.value.get(my_trap.x, my_trap.y);\n    //     assert(old_tile.success);\n    //     assert(old_tile.value == EMPTY);\n    //     //*(map_result.value._data[my_trap.y][my_trap.x]) = 0;\n    //     assert(map_result.value.set(my_trap.x, my_trap.y, my_trap_tiles[my_trap.sprung & 1]));\n    // }\n    // let their_trap_tiles = [TRAP_FOUND, TRAP_USED];\n    // for i in 0..MAX_TRAPS {\n    //     let my_trap = their_traps[i];\n    //     // let mut tile: u8 = TRAP_FOUND;\n    //     // if my_trap.sprung == 1 {\n    //     //     tile = TRAP_USED;\n    //     // }\n    //     let old_tile = map_result.value.get(my_trap.x, my_trap.y);\n    //     assert(old_tile.success);\n    //     assert(old_tile.value == EMPTY);\n    //     assert(map_result.value.set(my_trap.x, my_trap.y, their_trap_tiles[my_trap.sprung & 1]));\n    // }\n    for i in 0..5 {\n        let my_char = my_chars[i];\n        let mut tile = my_char.get_class();\n        assert(tile > 0);\n        let old_tile = map_result.value.get(my_char.get_x(), my_char.get_y());\n        assert((old_tile.success) & ((old_tile.value == EMPTY) | (old_tile.value >= NON_EMPTY_WALKABLE_TILE_MIN)));\n        assert(map_result.value.set(my_char.get_x(), my_char.get_y(), tile));\n    }\n    for i in 0..5 {\n        let my_char = their_chars[i];\n        let mut tile = my_char.get_class();\n        if tile == UNKNOWN_CLASS {\n            tile = UNKNOWN_CLASS_TILE;\n        }\n        let old_tile = map_result.value.get(my_char.get_x(), my_char.get_y());\n        assert((old_tile.success) & ((old_tile.value == EMPTY) | (old_tile.value >= NON_EMPTY_WALKABLE_TILE_MIN)));\n        assert(map_result.value.set(my_char.get_x(), my_char.get_y(), tile));\n    }\n\n    assert(map_result.success);\n    &mut map_result.value\n}\n\n#[test]\nfn test_can_move() {\n    let mut map = get_test_map(\n        [get_test_my_character(0, 2, 2, ROGUE), get_test_my_character(1, 2, 3, KNIGHT), get_test_my_character(2, 2, 4, MAGE), get_test_my_character(3, 2, 5, RITUALIST), get_test_my_character(4, 2, 6, ARCHER)],\n        [get_test_their_character(0, 22, 2, UNKNOWN_CLASS), get_test_their_character(1, 22, 3, UNKNOWN_CLASS), get_test_their_character(2, 22, 4, UNKNOWN_CLASS), get_test_their_character(3, 22, 5, UNKNOWN_CLASS), get_test_their_character(4, 22, 6, UNKNOWN_CLASS)],\n        [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE],\n        [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE],\n    );\n\n    let r1_result = map.can_move_to(7, 0);\n    assert(r1_result.success);\n    assert(r1_result.value == false);\n\n    let r2_result = map.can_move_to(6, 0);\n    assert(r2_result.success);\n    assert(r2_result.value == true);\n\n    let r3_result = map.can_move_to(0, 6);\n    assert(r3_result.success);\n    assert(r3_result.value == false);\n}\n\n\n\n// fn assert_neighbor(actor: T, x: u8, y: u8) where T: Character {\n//     assert(is_neighbor(actor, x, y));\n// }\n\n#[test]\nfn test_is_neighbor() {\n    let mut class = KNIGHT;\n    let c = Character {\n        id: 0,\n        x: 0,\n        y: 4,\n        status: 0,\n        health: 100,\n        class: class,\n        has_been_seen: 0,\n        target_x: 0,\n        target_y: 0,\n        damage: 123,\n    };\n\n    let r1_result = Map::is_neighbor(c.get_x(), c.get_y(), 0, 3);\n    assert(r1_result.success);\n    assert(r1_result.value == true);\n\n    let r2_result = Map::is_neighbor(c.get_x(), c.get_y(), 0, 5);\n    assert(r2_result.success);\n    assert(r2_result.value == true);\n\n    let r3_result = Map::is_neighbor(c.get_x(), c.get_y(), 1, 4);\n    assert(r3_result.success);\n    assert(r3_result.value == true);\n}\n\n// fn can_move_to(map: [[u8; globals::WIDTH]; globals::HEIGHT], x: u8, y: u8) -> u1 {\n//     assert(y < globals::HEIGHT);\n//     assert(x < globals::WIDTH);\n//     let tile = map[y][x];\n//     if (tile == 0) | (tile >= FLAG) { 1 }\n//     else { 0 }\n// }\n\n// #[test]\n// fn test_can_move() {\n//     let map = [\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL],\n//         [globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL],\n//         [globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL],\n//         [globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EMPTY,0, 0, globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL],\n//         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, globals::WATER, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, globals::WATER, 0, 0, 0, 0, 0],\n//     ];\n\n//     assert(can_move_to(map, 7, 0) == 0);\n//     assert(can_move_to(map, 6, 0) == 1);\n//     assert(can_move_to(map, 0, 6) == 0);\n// }\n\n\n// fn is_neighbor(actor: impl character::Character, x: u8, y: u8) -> bool {\n//     assert((actor.x < globals::WIDTH) & (actor.y < globals::HEIGHT) & (x < globals::WIDTH) & (y < globals::HEIGHT));\n//     assert((actor.x == x) | (actor.y == y));\n//     assert((actor.x != x) | (actor.y != y));\n//     if actor.x == x {\n//         if (actor.y == 0) {\n//             y == 1\n//         } else {\n//             (y == actor.y - 1) | (y == actor.y + 1)\n//         }\n//     } else {\n//         if (actor.x == 0) {\n//             x == 1\n//         } else {\n//             (x == actor.x - 1) | (x == actor.x + 1)\n//         }\n//     }\n// }\n// fn assert_neighbor(actor: Character, x: u8, y: u8) {\n//     assert(is_neighbor(actor, x, y));\n// }\n\n// #[test]\n// fn test_assert_neighbor() {\n//     let c = Character {\n//         id: 0,\n//         x: 0,\n//         y: 4,\n//         status: 0,\n//         health: 100,\n//         class: KNIGHT\n//     };\n//     assert_neighbor(c, 0, 3);\n//     assert_neighbor(c, 0, 5);\n//     assert_neighbor(c, 1, 4);\n// }\n\n// fn move_to(map: &mut [[u8; globals::WIDTH]; globals::HEIGHT], actor: &mut Character, energy: &mut u8, to_x: u8, to_y: u8) -> Field {\n//     assert(can_move_to(*map, to_x, to_y) == 1);\n//     assert(actor.class > 0);\n//     assert(actor.class < CLASS_COUNT);\n//     assert(actor.x < globals::WIDTH);\n//     assert(actor.y < globals::HEIGHT);\n//     assert(to_x < globals::WIDTH);\n//     assert(to_y < globals::HEIGHT);\n//     assert(map[actor.y][actor.x] == actor.class);\n//     assert_neighbor(*actor, to_x, to_y);\n//     if (actor.class == KNIGHT) | (actor.class == MAGE) | (actor.class == RITUALIST) {\n//         assert(*energy >= 4);\n//         *energy -= (4 as u8);\n//     } else {\n//         assert(*energy >= 3);\n//         *energy -= 3;\n//     }\n\n//     map[actor.y][actor.x] = 0; // TODO: instead of setting to 0, set to whatever it was before actor moved there!\n//     map[to_y][to_x] = actor.class;\n//     actor.x = to_x;\n//     actor.y = to_y;\n//     build_event(SEE_MOVE, actor.id, to_x, to_y)\n// }\n\n// #[test]\n// fn test_move_to() {\n//     let mut map = [\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL],\n//         [globals::WALL, EMPTY,KNIGHT,EMPTY,globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL],\n//         [globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL, 0, 0, globals::WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WALL, 0, 0, globals::WALL, EMPTY,EMPTY,EMPTY,globals::WALL],\n//         [globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EMPTY,0, 0, globals::WALL, globals::WALL, EMPTY,globals::WALL, globals::WALL],\n//         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, globals::WATER, globals::WATER, globals::WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, globals::WATER, globals::WATER, globals::WATER, 0, 0, 0, 0, 0],\n//     ];\n//     let mut c = Character {\n//         id: 0,\n//         x: 2,\n//         y: 4,\n//         status: 0,\n//         health: 100,\n//         class: KNIGHT\n//     };\n//     let mut energy = 12;\n//     assert(move_to(&mut map, &mut c, &mut energy, 2, 3) == build_event(SEE_MOVE, 0, 2, 3));\n// }\n\n// fn sneak_to(map: &mut [[u8; globals::WIDTH]; globals::HEIGHT], actor: &mut Character, energy: &mut u8, to_x: u8, to_y: u8) -> Field {\n//     assert(can_move_to(*map, to_x, to_y) == 1);\n//     assert(actor.class == ROGUE);\n//     assert(actor.x < globals::WIDTH);\n//     assert(actor.y < globals::HEIGHT);\n//     assert(to_x < globals::WIDTH);\n//     assert(to_y < globals::HEIGHT);\n//     assert(*energy >= 6);\n//     *energy -= 6;\n\n//     if map[actor.y][actor.x] == ROGUE { map[actor.y][actor.x] = 0; } // TODO: instead of setting to 0, set to whatever it was before actor moved there!\n//     //map[to_y][to_x] = actor.class;\n//     actor.x = to_x;\n//     actor.y = to_y;\n//     build_event(NO_EVENT, actor.id, 255, 255)\n// }\n\n","path":"/home/andreas/git_repositories/noir/skirmish/src/map.nr"},"51":{"source":"use crate::character::Character;\nuse crate::trap::Trap;\nuse crate::trap::parse_traps;\nuse crate::trap::serialize_traps;\nuse crate::map::Map;\nuse crate::Result;\nuse crate::WIDTH;\nuse crate::HEIGHT;\nuse crate::MAX_EVENTS;\nuse crate::EMPTY;\nuse crate::EVENTS_BUFFER_SIZE;\nuse crate::EVENTS_BUFFER_MASK;\nuse crate::MAX_TRAPS;\nuse crate::TRAPS_BUFFER_SIZE;\nuse crate::TRAPS_BUFFER_MASK;\nuse crate::character::get_test_my_character;\nuse crate::character::get_test_their_character;\nuse crate::map::get_test_map;\nuse crate::ARCHER;\nuse crate::KNIGHT;\nuse crate::MAGE;\nuse crate::ROGUE;\nuse crate::RITUALIST;\nuse crate::UNKNOWN_CLASS;\nuse crate::UNKNOWN_CLASS_TILE;\nuse crate::TRAP;\nuse crate::TRAP_FOUND;\nuse crate::TRAP_USED;\nuse crate::WALL;\nuse crate::WATER;\nuse dep::std;\n\nstruct Game {\n    my_chars: [&mut Character; 5],\n    their_chars: [&mut Character; 5],\n    traps: &mut [Trap; TRAPS_BUFFER_SIZE],\n    searched_traps: &mut [Trap; TRAPS_BUFFER_SIZE],\n    map: &mut Map,\n    events: &mut [Field; EVENTS_BUFFER_SIZE],\n    events_count: u64,\n    won: bool,\n    lost: bool,\n    trap_count: u64,\n    searched_trap_count: u64,\n}\n\nimpl Game {\n    pub fn lose(&mut self) -> bool {\n        let success = !(self.lost) & !(self.won);\n        (*self).lost = true;\n        // if !self.lost & !self.won {\n        //     self.lost = true;\n        //     success = true;\n        // }\n        success\n    }\n    pub fn win(&mut self) -> bool {\n        let success = !(self.lost) & !(self.won);\n        (*self).won = true;\n        success ////////////////////////////////////////////// TODO & (*self).add_event(crate::build_std_event(crate::WIN, 0, 0, 0))\n        //success// let mut success = false;\n        // if !self.lost & !self.won {\n        //     self.won = true;\n        //     success = true;\n        //     //(*self).add_event(crate::build_std_event(crate::WIN, 0, 0, 0))\n        // }\n        // success\n    }\n    pub fn add_event(&mut self, event: Field) -> bool {\n        //assert(MAX_EVENTS == 8);\n        // let mut success = false;\n        let ec = self.events_count;\n        self.events[ec & EVENTS_BUFFER_MASK] = event;\n        (*self).events_count = ec + 1;\n        ec < MAX_EVENTS\n        // if ec < MAX_EVENTS {\n        //     self.events[ec] = event;\n        //     *self.events_count = ec + 1;\n        //     success = true;\n        // }\n        // success\n    }\n\n    pub fn get_my_char(&mut self, id: u8) -> crate::Result<&mut Character> {\n        if id < 5 {\n            crate::Result {\n                value: self.my_chars[id],\n                success: true\n            }\n        } else {\n            crate::Result {\n                value: self.my_chars[0],\n                success: false\n            }\n        }\n    }\n\n    pub fn get_their_char(self, id: u8) -> Result<&mut Character> {\n        if id < 5 {\n            Result {\n                value: self.their_chars[id],\n                success: true\n            }\n        } else {\n            Result {\n                value: self.their_chars[0],\n                success: false\n            }\n        }\n    }\n    \n    pub fn get_trap_count(self) -> u64 {\n        self.trap_count\n    }\n\n    pub fn get_trap(self, id: u64) -> Result<Trap> {\n        // let mut trap = self.traps[0];\n        // let mut success = false;\n        // if (id as u64) < *self.trap_count {\n        //     trap = self.traps[id];\n        //     success = true;\n        // }\n        Result {\n            value: self.traps[id & TRAPS_BUFFER_MASK],\n            success: id < self.trap_count\n        }\n    }\n\n    pub fn add_my_trap(&mut self, trap: Trap) -> bool {\n        assert(MAX_TRAPS <= TRAPS_BUFFER_SIZE);\n        let tc = self.trap_count;\n        self.traps[tc & TRAPS_BUFFER_MASK] = trap;\n        (*self).trap_count = tc + 1;\n        \n        // if success {\n        //     self.traps[self.trap_count] = trap;\n        //     //self.trap_count += 1;\n        // }\n        let mut tile = TRAP;\n        if *trap.sprung == 1 {\n            tile = TRAP_USED;\n        }\n        tc < MAX_TRAPS & self.map.set(trap.x, trap.y, tile)\n    }\n    \n    pub fn get_their_trap_count(self) -> u64 {\n        self.searched_trap_count\n    }\n\n    pub fn get_their_trap(self, id: u64) -> Result<Trap> {\n        Result {\n            value: self.searched_traps[id & TRAPS_BUFFER_MASK],\n            success: id < self.searched_trap_count\n        }\n        // if (id as u64) < *self.searched_trap_count {\n        //     Result {\n        //         value: self.searched_traps[id],\n        //         success: true\n        //     }\n        // } else {\n        //     Result {\n        //         value: Trap { x: 0, y: 0, sprung: &mut 0, damage: 0 },\n        //         success: false\n        //     }\n        // }\n    }\n\n    pub fn add_their_trap(&mut self, trap: Trap) -> bool {\n        assert(MAX_TRAPS <= TRAPS_BUFFER_SIZE);\n        let tc = self.searched_trap_count;\n        self.searched_traps[tc & TRAPS_BUFFER_MASK] = trap;\n        (*self).searched_trap_count = tc + 1;\n        let mut tile = TRAP_FOUND;\n        if *trap.sprung == 1 {\n            tile = TRAP_USED;\n        }\n        tc < MAX_TRAPS & self.map.set(trap.x, trap.y, tile)\n    }\n\n    pub fn get_tile(self, x: u8, y: u8) -> Result<u8> {\n        self.map.get(x, y)\n    }\n\n    pub fn set_tile(mut self, x: u8, y: u8, tile: u8) -> bool {\n        //if (x < WIDTH) & (y < HEIGHT) {\n            self.map.set(x, y, tile)\n        // } else {\n        //     false\n        // }\n    }\n\n    fn serialize_chars(chars: [&mut Character; 5]) -> Result<Field> {\n        let mut success = true;\n        let mut result: [u8; 32] = [0; 32];\n        for i in 0..5 {\n            let serialized_result = chars[i].serialize();\n            success &= serialized_result.success;\n            let serialized = serialized_result.value;\n            for j in 0..6 {\n                result[2 + i * 6 + j] = serialized[j];\n            }\n        }\n        Result {\n            value: std::field::bytes32_to_field(result),\n            success: success\n        }\n    }\n\n    // pub fn serialize_my_chars(self) -> Result<Field> {\n    //     Game::serialize_chars(self.my_chars)\n    // }\n\n    pub fn serialize_their_chars(self) -> Result<Field> {\n        Game::serialize_chars(self.their_chars)\n    }\n\n    fn handle_see_move(&mut self, actor_id: u8, x: u8, y: u8) -> bool {\n        //assert(actor_id < 5);\n        // let actor_result = game.get_their_char(actor_id);\n        // assert(actor_result.success);\n        true\n        // let mut result = false;\n        // if actor_id < 5 {\n        //     let mut actor_result = game.get_their_char(actor_id);\n        //     if actor_result.success {\n        //         let mut actor = actor_result.value;\n        //         let is_neighbor_result = Map::is_neighbor(actor.get_x(), actor.get_y(), x, y);\n        //         if is_neighbor_result.success {\n        //             if is_neighbor_result.value {\n        //                 let can_move_to = game.map.can_move_to(x, y);\n        //                 if can_move_to.success & can_move_to.value {\n        //                     result = actor.set_pos(x, y);\n        //                     //result = true;\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // result\n    }\n\n    pub fn is_valid(self) -> bool {\n        false\n    }\n\n    pub fn parse_characters(chars: Field) -> Result<[Character; 5]> {\n        let Result { value: c0, success: c0_success } = Character::parse_character(0, chars);\n        let Result { value: c1, success: c1_success } = Character::parse_character(1, chars);\n        let Result { value: c2, success: c2_success } = Character::parse_character(2, chars);\n        let Result { value: c3, success: c3_success } = Character::parse_character(3, chars);\n        let Result { value: c4, success: c4_success } = Character::parse_character(4, chars);\n        Result {\n            value: [c0, c1, c2, c3, c4],\n            success: c0_success & c1_success & c2_success & c3_success & c4_success\n        }\n    }\n\n    pub fn build(my_chars: Field, their_chars: Field, my_traps: Field, their_traps: Field, map: [[u8; WIDTH]; HEIGHT]) -> crate::Result<Game> {\n        //let mut success = true;\n        let mut c0_result = Character::parse_character(0, my_chars);\n        let mut c0 = &mut c0_result.value;\n        let mut c1_result = Character::parse_character(1, my_chars);\n        let mut c1 = &mut c1_result.value;\n        let mut c2_result = Character::parse_character(2, my_chars);\n        let mut c2 = &mut c2_result.value;\n        let mut c3_result = Character::parse_character(3, my_chars);\n        let mut c3 = &mut c3_result.value;\n        let mut c4_result = Character::parse_character(4, my_chars);\n        let mut c4 = &mut c4_result.value;\n        //success &= c0_result.success & c1_result.success & c2_result.success & c3_result.success & c4_result.success;\n\n        let mut e0_result = Character::parse_character(0, their_chars);\n        let mut e0 = &mut e0_result.value;\n        let mut e1_result = Character::parse_character(1, their_chars);\n        let mut e1 = &mut e1_result.value;\n        let mut e2_result = Character::parse_character(2, their_chars);\n        let mut e2 = &mut e2_result.value;\n        let mut e3_result = Character::parse_character(3, their_chars);\n        let mut e3 = &mut e3_result.value;\n        let mut e4_result = Character::parse_character(4, their_chars);\n        let mut e4 = &mut e4_result.value;\n        //success &= e0_result.success & e1_result.success & e2_result.success & e3_result.success & e4_result.success;\n\n        let mut my_traps_result = parse_traps(my_traps);\n        let mut my_traps = my_traps_result.value;\n        let mut their_traps_result = parse_traps(their_traps);\n        let mut their_traps = their_traps_result.value;\n        //success &= my_traps_result.success & their_traps_result.success;\n        \n        let mut map_result = Map::build(map);\n        let mut my_map = &mut map_result.value;\n        //success &= map_result.success;\n\n        crate::Result {\n            value: Game {\n                my_chars: [c0, c1, c2, c3, c4],\n                their_chars: [e0, e1, e2, e3, e4],\n                traps: &mut my_traps,\n                searched_traps: &mut their_traps,\n                map: my_map,\n                events: &mut [0; MAX_EVENTS],\n                events_count: 0,\n                won: false,\n                lost: false,\n                trap_count: my_traps_result.count,\n                searched_trap_count: their_traps_result.count,\n            },\n            success: c0_result.success & c1_result.success & c2_result.success & c3_result.success & c4_result.success & e0_result.success & e1_result.success & e2_result.success & e3_result.success & e4_result.success & my_traps_result.success & their_traps_result.success & map_result.success,\n        }\n    }\n}\n\npub fn get_test_my_chars() -> [&mut Character; 5] {\n    [\n        &mut get_test_my_character(0, 2, 2, ARCHER),\n        &mut get_test_my_character(1, 2, 3, KNIGHT),\n        &mut get_test_my_character(2, 2, 4, MAGE),\n        &mut get_test_my_character(3, 2, 5, ROGUE),\n        &mut get_test_my_character(4, 2, 6, RITUALIST),\n    ]\n}\n\npub fn get_test_game() -> Game {\n    let mut c0 = get_test_my_character(0, 2, 2, ARCHER);\n    let mut c1 = get_test_my_character(1, 2, 3, KNIGHT);\n    let mut c2 = get_test_my_character(2, 2, 4, MAGE);\n    let mut c3 = get_test_my_character(3, 2, 5, ROGUE);\n    let mut c4 = get_test_my_character(4, 2, 6, RITUALIST);\n\n    let mut e0 = get_test_their_character(0, 22, 2, ARCHER);\n    let mut e1 = get_test_their_character(1, 22, 3, KNIGHT);\n    let mut e2 = get_test_their_character(2, 22, 4, MAGE);\n    let mut e3 = get_test_their_character(3, 22, 5, ROGUE);\n    let mut e4 = get_test_their_character(4, 22, 6, RITUALIST);\n\n    // let my_traps = [0; 32];\n    // let their_traps = [0; 32];\n    let mut my_traps_result = parse_traps(0x0000ffff00000000000000000000000000000000000000000000000000000000);\n    let mut my_traps = my_traps_result.value;\n    let mut their_traps_result = parse_traps(0x0000ffff00000000000000000000000000000000000000000000000000000000);\n    let mut their_traps = their_traps_result.value;\n    //let mut map = get_test_map([c0, c1, c2, c3, c4], [e0, e1, e2, e3, e4], my_traps, their_traps);\n\n    let mut map = get_test_map(\n        [c0, c1, c2, c3, c4], //[get_test_my_character(0, 2, 2, ROGUE), get_test_my_character(1, 2, 3, KNIGHT), get_test_my_character(2, 2, 4, MAGE), get_test_my_character(3, 2, 5, RITUALIST), get_test_my_character(4, 2, 6, ARCHER)],\n        [e0, e1, e2, e3, e4], //[get_test_their_character(0, 22, 2, UNKNOWN_CLASS), get_test_their_character(1, 22, 3, UNKNOWN_CLASS), get_test_their_character(2, 22, 4, UNKNOWN_CLASS), get_test_their_character(3, 22, 5, UNKNOWN_CLASS), get_test_their_character(4, 22, 6, UNKNOWN_CLASS)],\n        [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE], /// TODO: using my_traps here causes exception on compile\n        [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE],\n    );\n\n    Game {\n        my_chars: [&mut c0, &mut c1, &mut c2, &mut c3, &mut c4],\n        their_chars: [&mut e0, &mut e1, &mut e2, &mut e3, &mut e4],\n        traps: &mut my_traps,\n        searched_traps: &mut their_traps,\n        map: map,\n        events: &mut [0; MAX_EVENTS],\n        events_count: 0,\n        won: false,\n        lost: false,\n        trap_count: my_traps_result.count,\n        searched_trap_count: their_traps_result.count,\n    }\n}\n\n#[test]\nfn test_lose() {\n    let mut game = get_test_game();\n    assert(game.lose());\n    assert(game.lost);\n    assert(!(game.won));\n    assert(!game.lose());\n    assert(!game.win());\n}\n\n#[test]\nfn test_win() {\n    let mut game = get_test_game();\n    assert(game.win());\n    assert(game.won);\n    assert(!(game.lost));\n    assert(!game.win());\n    assert(!game.lose());\n}\n\n// #[test]\n// fn test_get_update_my_char() {\n//     let mut game = get_test_game();\n//     let mut char_result = game.get_my_char(0);\n//     assert(char_result.success);\n//     let mut c0 = char_result.value;\n    \n//     let old_x = c0.get_x();\n//     let old_y = c0.get_y();\n\n//     assert(c0.set_pos(old_x + 3, old_y + 3));\n\n//     assert(game.get_my_char(0).value.get_x() == old_x + 3);\n//     assert(game.get_my_char(0).value.get_y() == old_y + 3);\n// }\n\n#[test]\nfn test_get_update_their_char() {\n    let mut game = get_test_game();\n    let mut char_result = game.get_their_char(0);\n    assert(char_result.success);\n    let mut c0 = char_result.value;\n    \n    let old_x = c0.get_x();\n    let old_y = c0.get_y();\n\n    assert(c0.set_pos(old_x + 3, old_y + 3));\n\n    assert(game.get_their_char(0).value.get_x() == old_x + 3);\n    assert(game.get_their_char(0).value.get_y() == old_y + 3);\n}\n\n#[test]\nfn test_get_traps() {\n    let mut game = get_test_game();\n    let trap_count = game.get_trap_count();\n    assert(trap_count == 0, f\"trap count: {trap_count}\");\n\n    assert(game.add_my_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n    assert(game.get_trap_count() == 1);\n\n    let mut trap_result = game.get_trap(0);\n    assert(trap_result.success);\n    assert(trap_result.value.damage == 60);\n\n    for i in 1..MAX_TRAPS {\n        assert(game.add_my_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n        assert(game.get_trap_count() == i + 1);\n    }\n\n    assert(!game.add_my_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n}\n\n#[test]\nfn test_get_their_traps() {\n    let mut game = get_test_game();\n    let trap_count = game.get_their_trap_count();\n    assert(trap_count == 0, f\"trap count: {trap_count}\");\n\n    assert(game.add_their_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n    assert(game.get_their_trap_count() == 1);\n\n    let mut trap_result = game.get_their_trap(0);\n    assert(trap_result.success);\n    assert(trap_result.value.damage == 60);\n\n    for i in 1..MAX_TRAPS {\n        assert(game.add_their_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n        assert(game.get_their_trap_count() == i + 1);\n    }\n\n    assert(!game.add_their_trap(Trap { x: 1, y: 1, sprung: &mut 0, damage: 60 }));\n}\n\n#[test]\nfn test_get_tile() {\n    let mut game = get_test_game();\n    let mut tile_result = game.get_tile(0, 0);\n    assert(tile_result.success);\n    assert(tile_result.value == 0);\n\n    assert(game.set_tile(0, 0, 1));\n    let mut tile_result = game.get_tile(0, 0);\n    assert(tile_result.success);\n    assert(tile_result.value == 1);\n\n    assert(game.set_tile(WIDTH - 1 as u8, 0, 1));\n    assert(game.set_tile(0, HEIGHT - 1 as u8, 1));\n    assert(!game.set_tile(WIDTH as u8, 0, 1));\n    assert(!game.set_tile(0, HEIGHT as u8, 1));\n}\n\n#[test]\nfn test_parse_game() {\n    let crate::Result { value: mut game, success } = Game::build(\n        0x2202643f0f008203643f0f00a224643604006205643f0f004206643f0f00,\n        0x1602ff1f0f001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00, 0x000210020300FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, 0x0000ffff00000000000000000000000000000000000000000000000000000000, [\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, ARCHER, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [WALL, WALL, KNIGHT,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [WALL, EMPTY,MAGE,  EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, EMPTY,ROGUE,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, WALL, RITUALIST,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n    ]);\n\n    // assert(game.my_chars[0].get_class() == ARCHER);\n    // assert(game.my_chars[1].get_class() == KNIGHT);\n    // assert(game.my_chars[2].get_class() == MAGE);\n    // assert(game.my_chars[3].get_class() == ROGUE);\n    // assert(game.my_chars[4].get_class() == RITUALIST);\n\n    assert(game.their_chars[0].get_class() == UNKNOWN_CLASS);\n    assert(game.their_chars[1].get_class() == UNKNOWN_CLASS);\n    assert(game.their_chars[2].get_class() == UNKNOWN_CLASS);\n    assert(game.their_chars[3].get_class() == UNKNOWN_CLASS);\n    assert(game.their_chars[4].get_class() == UNKNOWN_CLASS);\n\n    assert(game.get_trap_count() == 2, game.get_trap_count());\n    assert(game.get_their_trap_count() == 0, game.get_their_trap_count());\n\n    // assert(game.my_chars[0].get_x() == 2);\n    // assert(game.my_chars[0].get_y() == 2);\n    // assert(game.my_chars[1].get_x() == 2);\n    // assert(game.my_chars[1].get_y() == 3);\n    // assert(game.my_chars[2].get_x() == 2);\n    // assert(game.my_chars[2].get_y() == 4);\n    // assert(game.my_chars[3].get_x() == 2);\n    // assert(game.my_chars[3].get_y() == 5);\n    // assert(game.my_chars[4].get_x() == 2);\n    // assert(game.my_chars[4].get_y() == 6);\n\n    assert(game.their_chars[0].get_x() == 22);\n    assert(game.their_chars[0].get_y() == 2);\n    assert(game.their_chars[1].get_x() == 22);\n    assert(game.their_chars[1].get_y() == 3);\n    assert(game.their_chars[2].get_x() == 22);\n    assert(game.their_chars[2].get_y() == 4);\n    assert(game.their_chars[3].get_x() == 22);\n    assert(game.their_chars[3].get_y() == 5);\n\n    // assert(game.my_chars[0].get_health() == 0x64, game.my_chars[0].get_health());\n    // assert(game.my_chars[1].get_health() == 0x64);\n    // assert(game.my_chars[2].get_health() == 0x64);\n    // assert(game.my_chars[3].get_health() == 0x64);\n    // assert(game.my_chars[4].get_health() == 0x64);\n\n    assert(game.their_chars[0].get_health() == 0xff);\n    assert(game.their_chars[1].get_health() == 0xff);\n    assert(game.their_chars[2].get_health() == 0xff);\n    assert(game.their_chars[3].get_health() == 0xff);\n    assert(game.their_chars[4].get_health() == 0xff);\n\n    // assert(game.my_chars[0].get_energy_per_move() == 0x03);\n    // assert(game.my_chars[1].get_energy_per_move() == 0x04);\n    // assert(game.my_chars[2].get_energy_per_move() == 0x04);\n    // assert(game.my_chars[3].get_energy_per_move() == 0x03);\n    // assert(game.my_chars[4].get_energy_per_move() == 0x04);\n\n    // assert(game.their_chars[0].get_energy_per_move() == 0x03);\n    // assert(game.their_chars[1].get_energy_per_move() == 0x03);\n    // assert(game.their_chars[2].get_energy_per_move() == 0x03);\n    // assert(game.their_chars[3].get_energy_per_move() == 0x03);\n    // assert(game.their_chars[4].get_energy_per_move() == 0x03);\n\n    // assert(game.my_chars[0].get_id() == 0);\n    // assert(game.my_chars[1].get_id() == 1);\n    // assert(game.my_chars[2].get_id() == 2);\n    // assert(game.my_chars[3].get_id() == 3);\n    // assert(game.my_chars[4].get_id() == 4);\n\n    // assert(game.their_chars[0].get_id() == 0);\n    // assert(game.their_chars[1].get_id() == 1);\n    // assert(game.their_chars[2].get_id() == 2);\n    // assert(game.their_chars[3].get_id() == 3);\n    // assert(game.their_chars[4].get_id() == 4);\n\n    // assert(game.my_chars[0].get_target_x() == 31, game.my_chars[0].get_target_x());\n    // assert(game.my_chars[0].get_target_y() == 15, game.my_chars[0].get_target_y());\n    // assert(game.my_chars[1].get_target_x() == 31, game.my_chars[1].get_target_x());\n    // assert(game.my_chars[1].get_target_y() == 15, game.my_chars[1].get_target_y());\n    // assert(game.my_chars[2].get_target_x() == 22, game.my_chars[2].get_target_x());\n    // assert(game.my_chars[2].get_target_y() ==  4, game.my_chars[2].get_target_y());\n    // assert(game.my_chars[3].get_target_x() == 31, game.my_chars[3].get_target_x());\n    // assert(game.my_chars[3].get_target_y() == 15, game.my_chars[3].get_target_y());\n    // assert(game.my_chars[4].get_target_x() == 31, game.my_chars[4].get_target_x());\n    // assert(game.my_chars[4].get_target_y() == 15, game.my_chars[4].get_target_y());\n\n    // // assert(game.their_chars[0].get_target_x() == 0xff);\n    // // assert(game.their_chars[0].get_target_y() == 0xff);\n    // // assert(game.their_chars[1].get_target_x() == 0xff);\n    // // assert(game.their_chars[1].get_target_y() == 0xff);\n    // // assert(game.their_chars[2].get_target_x() == 0xff);\n    // // assert(game.their_chars[2].get_target_y() == 0xff);\n    // // assert(game.their_chars[3].get_target_x() == 0xff);\n    // // assert(game.their_chars[3].get_target_y() == 0xff);\n    // // assert(game.their_chars[4].get_target_x() == 0xff);\n    // // assert(game.their_chars[4].get_target_y() == 0xff);\n\n    // assert(game.my_chars[0].get_status() == 0);\n    // assert(game.my_chars[1].get_status() == 0);\n    // assert(game.my_chars[2].get_status() == 2);\n    // assert(game.my_chars[3].get_status() == 0);\n    // assert(game.my_chars[4].get_status() == 0);\n\n    assert(game.their_chars[0].get_status() == 0);\n    assert(game.their_chars[1].get_status() == 0);\n    assert(game.their_chars[2].get_status() == 0);\n    assert(game.their_chars[3].get_status() == 0);\n    assert(game.their_chars[4].get_status() == 0);\n\n\n    assert(game.get_tile(0, 0).value == 0);\n    assert(game.get_tile(0, 1).value == 0);\n    assert(game.get_tile(0, 2).value == 0);\n    assert(game.get_tile(0, 3).value == WALL);\n    assert(game.get_tile(0, 4).value == WALL);\n    assert(game.get_tile(0, 5).value == WALL);\n    assert(game.get_tile(0, 6).value == WALL);\n    assert(game.get_tile(0, 7).value == 0);\n    assert(game.get_tile(0, 8).value == 0);\n    assert(game.get_tile(0, 9).value == 0);\n    assert(game.get_tile(1, 0).value == 0);\n    assert(game.get_tile(1, 1).value == 0);\n    assert(game.get_tile(1, 2).value == 0);\n    assert(game.get_tile(1, 3).value == WALL);\n    assert(game.get_tile(1, 4).value == EMPTY);\n    assert(game.get_tile(1, 5).value == EMPTY);\n    assert(game.get_tile(1, 6).value == WALL);\n    assert(game.get_tile(1, 7).value == 0);\n    assert(game.get_tile(1, 8).value == 0);\n    assert(game.get_tile(1, 9).value == 0);\n    assert(game.get_tile(2, 0).value == 0);\n    assert(game.get_tile(2, 1).value == 0);\n    assert(game.get_tile(2, 2).value == ARCHER);\n    assert(game.get_tile(2, 3).value == KNIGHT);\n\n\n}","path":"/home/andreas/git_repositories/noir/skirmish/src/game.nr"},"52":{"source":"use dep::std;\n\n// MAP\nglobal WIDTH = 32;\nglobal HEIGHT = 10;\n\n// CLASSES\nglobal UNKNOWN_CLASS = 0 as u8;\nglobal ARCHER = 1 as u8;\nglobal RITUALIST = 2 as u8;\nglobal ROGUE = 3 as u8;\nglobal KNIGHT = 4 as u8;\nglobal MAGE = 5 as u8;\nglobal CLASS_COUNT = 6 as u8;\n\n// ACTIONS\nglobal WAIT = 0 as u8;\nglobal SNEAK = 1 as u8;\nglobal MOVE = 2 as u8;\nglobal RITUAL = 3 as u8;\nglobal SEARCH = 4 as u8;\nglobal ATTACK = 5 as u8;\nglobal SET_TRAP = 6 as u8;\nglobal CAST_FIREBALL = 7 as u8;\nglobal DRAW = 8 as u8;\nglobal TRIGGER_TRAP = 9 as u8;\nglobal DISARM_TRAP = 10 as u8;\nglobal ACTION_COUNT = 11 as u8;\n\n// EVENTS\nglobal NO_EVENT = 0  as u8;\nglobal SEE_MOVE = 1  as u8;// actor_id = their_char when receive\nglobal SEE_RITUAL = 2  as u8; // actor_id = their_char when receive\nglobal SEE_SEARCH_TRAP = 3  as u8; // actor_id = their_char when receive\nglobal RECEIVE_ATTACK = 4  as u8; // actor_id = their_char when receive\nglobal SEE_CAST = 5 as u8; // actor_id = their_char when receive\nglobal SEE_DRAW = 6 as u8; // actor_id = their_char when receive\nglobal TRIGGERED_TRAP = 7 as u8; // actor_id = my_char when receive\nglobal WIN = 8 as u8;\nglobal FOUND_TRAP = 9 as u8; // actor_id = my_char when receive\nglobal SEE_CHARS = 10 as u8; // actor_id = their_char when receive, got health & class\nglobal RECEIVE_DAMAGE = 11 as u8; // actor_id = their_char when receive\nglobal DESTROY = 12 as u8; // actor_id = tile\nglobal DEATH = 13 as u8; // actor_id = their_char when receive\nglobal EVENT_COUNT = 14 as u8;\n\n// ATTACKS\nglobal ATTACK_MELEE = 0 as u8;\nglobal ATTACK_RANGED = 1 as u8;\nglobal ATTACK_FIREBALL = 2 as u8;\nglobal ATTACK_COUNT = 3 as u8;\n\n// TILES\nglobal EMPTY = 0 as u8;\nglobal UNKNOWN_CLASS_TILE = 6 as u8;\nglobal WALL = 7 as u8;\nglobal WATER = 8 as u8;\nglobal NON_EMPTY_WALKABLE_TILE_MIN = 9 as u8;\nglobal FLAG = 9 as u8;\nglobal TRAP = 10 as u8;\nglobal TRAP_USED = 11 as u8;\nglobal TRAP_FOUND = 12 as u8;\nglobal BODY = 13 as u8;\nglobal BODY_LOOTED = 14 as u8;\nglobal FOG = 15 as u8;\nglobal TILE_COUNT = 16 as u8;\n\n// STATUS\nglobal STATUS_COUNT = 16  as u8; // just to be more in line with the other constants, actually used as a counter\n\n// GAMEPLAY\nglobal MAX_TRAPS = 15; // note: only lowest bit of first byte of field is usable! => ! Field = 1 bit + 31 bytes!\nglobal TRAPS_BUFFER_SIZE = 16;\nglobal TRAPS_BUFFER_MASK = 15; // has to be 2^n - 1\nglobal MAX_ACTIONS = 8;\nglobal MAX_EVENTS = 8;\nglobal EVENTS_BUFFER_SIZE = 8;\nglobal EVENTS_BUFFER_MASK = 7; // has to be 2^n - 1\n\nstruct Result<T> {\n    value: T,\n    success: bool\n}\n\n////////////// CHARACTER\nmod character;\nuse character::Character;\nuse character::get_test_my_character;\nuse character::get_test_their_character;\nmod trap;\nuse trap::Trap;\nuse trap::parse_traps;\nuse trap::serialize_traps;\nmod map;\nuse map::Map;\nuse map::get_test_map;\nmod game;\nuse game::Game;\nmod event;\nuse event::Event;\nuse event::build_std_event;\nuse event::build_value_event;\nuse event::build_subtype_value_event;\nuse event::parse_event;\n\nfn move_to(map: &mut Map, actor: &mut Character, energy: &mut u8, to_x: u8, to_y: u8, exec: bool) -> Result<Field> {\n    let mut success = true;\n    if exec {\n    let can_move_to = map.can_move_to(to_x, to_y);\n    success = can_move_to.success;\n    // let success = can_move_to.success & can_move_to.value &\n    //               ((*actor).get_class() > 0) & ((*actor).get_class() < CLASS_COUNT) &\n    //               ((*actor).get_x() < WIDTH) & ((*actor).get_y() < HEIGHT) &\n    //               (to_x < WIDTH) & (to_y < HEIGHT) &\n    //               (map[(*actor).get_y()][(*actor).get_x()] == (*actor).get_class());\n    // assert(can_move_to(*map, to_x, to_y) == 1);\n    // assert((*actor).get_class() > 0);\n    // assert((*actor).get_class() < CLASS_COUNT);\n    // assert((*actor).get_x() < WIDTH);\n    // assert((*actor).get_y() < HEIGHT);\n    // assert(to_x < WIDTH);\n    // assert(to_y < HEIGHT);\n    // assert(map[(*actor).get_y()][(*actor).get_x()] == (*actor).get_class());\n    let current_tile = map.get(actor.get_x(), actor.get_y());\n    success &= current_tile.success & (current_tile.value == actor.get_class());\n\n    // assert_neighbor((*actor), to_x, to_y);\n    let is_neighbor = Map::is_neighbor(actor.get_x(), actor.get_y(), to_x, to_y);\n    success &= is_neighbor.success;\n\n    let energy_cost = actor.get_energy_per_move();\n        if energy_cost > *energy {\n            *energy = 0;\n            success = false;\n            //Result { value: 0, success: false }\n        } else {\n            *energy = *energy - energy_cost;\n        }\n    //}\n\n    let erase_result = map.set(actor.get_x(), actor.get_y(), 0); // TODO: instead of setting to 0, set to whatever it was before actor moved there!\n    let set_map_result = map.set(to_x, to_y, actor.get_class());\n    let set_char_result = actor.set_pos(to_x, to_y); //actor=>set_pos(to_x, to_y);\n    // if (!erase_result) | (!set_map_result) | (!set_char_result) {\n    //     Result { value: 0, success: false }\n    // }\n    success &= erase_result & set_map_result & set_char_result;\n    }\n    Result {\n        value: build_std_event(SEE_MOVE, actor.get_id(), to_x, to_y),\n        success: success\n    }\n}\n\n#[test]\nfn test_move_to() {\n    let mut map_result = Map::build([\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [WALL, WALL, EMPTY,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [WALL, EMPTY,KNIGHT,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, EMPTY,EMPTY,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, WALL, EMPTY,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n    ]);\n    assert(map_result.success == true);\n    let mut map = map_result.value;\n    let mut class = KNIGHT;\n    let mut c = Character {\n        id: 0,\n        x: 2,\n        y: 4,\n        status: 0,\n        health: 100,\n        class: class,\n        has_been_seen: 0,\n        target_x: 0,\n        target_y: 0,\n        damage: 123,\n    };\n    let mut energy = 12;\n    let result = move_to(&mut map, &mut c, &mut energy, 2, 3, true);\n    assert(result.success == true);\n    assert(result.value == build_std_event(SEE_MOVE, 0, 2, 3));\n}\n\nfn sneak_to(map: &mut Map, actor: &mut Character, energy: &mut u8, to_x: u8, to_y: u8, exec: bool) -> bool {\n    let mut success = true;\n    if exec {\n        let can_move_to = map.can_move_to(to_x, to_y);\n        success &= can_move_to.success;\n        let current_tile = map.get(actor.get_x(), actor.get_y());\n        success &= current_tile.success & (current_tile.value == actor.get_class());\n        // assert(can_move_to(*map, to_x, to_y) == 1);\n        // assert((*actor).get_class() == ROGUE);\n        // assert(((*actor).get_x() < WIDTH) & ((*actor).get_y() < HEIGHT));\n        // assert((to_x < WIDTH) & (to_y < HEIGHT));\n        // assert(*energy >= 6);\n        \n        // assert_neighbor((*actor), to_x, to_y);\n        let is_neighbor = Map::is_neighbor(actor.get_x(), actor.get_y(), to_x, to_y);\n        success &= is_neighbor.success;\n\n        let can_sneak = actor.can_sneak();\n        success &= can_sneak;\n\n        let energy_cost = (*actor).get_energy_per_sneak();\n        if energy_cost > *energy {\n            *energy = 0;\n            success = false;\n            //Result { value: 0, success: false }\n        } else {\n            *energy = *energy - energy_cost;\n        }\n\n        let erase_result = map.set(actor.get_x(), actor.get_y(), 0); // TODO: instead of setting to 0, set to whatever it was before actor moved there!\n        let set_map_result = map.set(to_x, to_y, actor.get_class());\n        let set_char_result = actor.set_pos(to_x, to_y); //actor=>set_pos(to_x, to_y);\n        success &= erase_result & set_map_result & set_char_result;\n    }\n\n    success\n}\n\nfn get_actor_from_move(mut move: u32) -> u8 {\n    if (move % 2) == 1 {\n        move -= 1; //((move % 10) - 1) >> 1 // actually not needed ... but clearer this way\n    }\n    let single_digit: u32 = (move % 10 as u32) >> 1;\n    single_digit as u8\n}\n\nfn get_data_hash(secret: [u8], characters: [u8], their_characters: [u8], traps: [u8], map: [[u8; WIDTH]; HEIGHT], searched_traps: [u8]) -> [u8; 32] {\n    assert(secret.len() == 32);\n    assert(characters.len() == 32);\n    assert(traps.len() == 32);\n    assert(their_characters.len() == 32);\n\n    let mut data: [u8; WIDTH * HEIGHT + 32 * 5] = [0; WIDTH * HEIGHT + 32 * 5];\n    for i in 0..HEIGHT {\n        for j in 0..WIDTH {\n            assert(i < 10);\n            assert(j < WIDTH);\n            let index = (i as u64) * (WIDTH as u64) + (j as u64);\n            data[index] = map[i][j];\n        }\n    }\n    let offset = (WIDTH as u64) * (HEIGHT as u64);\n    for i in 0..32 {\n        data[offset + i] = secret[i];\n        data[offset + i + 32] = characters[i];\n        data[offset + i + 64] = traps[i];\n        data[offset + i + 96] = searched_traps[i];\n        data[offset + i + 128] = their_characters[i];\n    }\n    // let offset = WIDTH * HEIGHT + 32 * 3;\n    // for i in 0..10 {\n    //     data[offset + i * 4] = (searched_traps[i] & 255) as u8;\n    //     data[offset + i * 4 + 1] = ((searched_traps[i] >> 8) & 255) as u8;\n    //     data[offset + i * 4 + 2] = ((searched_traps[i] >> 16) & 255) as u8;\n    //     data[offset + i * 4 + 3] = ((searched_traps[i] >> 24) & 255) as u8;\n    // }\n    std::hash::blake3(data)\n}\n\n\n\n\n\n\n// #[test]\n// fn get_demo_game() {\n//     let mut c0 = get_test_my_character(0, 2, 2, ARCHER);\n//     let mut c1 = get_test_my_character(1, 2, 3, KNIGHT);\n//     let mut c2 = get_test_my_character(2, 2, 4, MAGE);\n//     let mut c3 = get_test_my_character(3, 2, 5, ROGUE);\n//     let mut c4 = get_test_my_character(4, 2, 6, RITUALIST);\n\n//     let mut e0 = get_test_their_character(0, 22, 2, UNKNOWN_CLASS);\n//     let mut e1 = get_test_their_character(1, 22, 3, UNKNOWN_CLASS);\n//     let mut e2 = get_test_their_character(2, 22, 4, UNKNOWN_CLASS);\n//     let mut e3 = get_test_their_character(3, 22, 5, UNKNOWN_CLASS);\n//     let mut e4 = get_test_their_character(4, 22, 6, UNKNOWN_CLASS);\n\n//     *c2.status = 2;\n\n//     // let my_traps = [0; 32];\n//     // let their_traps = [0; 32];\n//     let mut my_traps_result = parse_traps(0x0000ffff00000000000000000000000000000000000000000000000000000000);\n//     let mut my_traps = my_traps_result.value;\n//     let mut their_traps_result = parse_traps(0x0000ffff00000000000000000000000000000000000000000000000000000000);\n//     let mut their_traps = their_traps_result.value;\n//     //let mut map = get_test_map([c0, c1, c2, c3, c4], [e0, e1, e2, e3, e4], my_traps, their_traps);\n\n//     let mut map = get_test_map(\n//         [c0, c1, c2, c3, c4], //[get_test_my_character(0, 2, 2, ROGUE), get_test_my_character(1, 2, 3, KNIGHT), get_test_my_character(2, 2, 4, MAGE), get_test_my_character(3, 2, 5, RITUALIST), get_test_my_character(4, 2, 6, ARCHER)],\n//         [e0, e1, e2, e3, e4], //[get_test_their_character(0, 22, 2, UNKNOWN_CLASS), get_test_their_character(1, 22, 3, UNKNOWN_CLASS), get_test_their_character(2, 22, 4, UNKNOWN_CLASS), get_test_their_character(3, 22, 5, UNKNOWN_CLASS), get_test_their_character(4, 22, 6, UNKNOWN_CLASS)],\n//         [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE], /// TODO: using my_traps here causes exception on compile\n//         [Trap { x: 255, y: 255, sprung: &mut 0, damage: 0 }; TRAPS_BUFFER_SIZE],\n//     );\n\n//     let game = Game {\n//         my_chars: [&mut c0, &mut c1, &mut c2, &mut c3, &mut c4],\n//         their_chars: [&mut e0, &mut e1, &mut e2, &mut e3, &mut e4],\n//         traps: &mut my_traps,\n//         searched_traps: &mut their_traps,\n//         map: map,\n//         events: &mut [0; MAX_EVENTS],\n//         events_count: &mut 0,\n//         won: &mut false,\n//         lost: &mut false,\n//         trap_count: &mut my_traps_result.count,\n//         searched_trap_count: &mut their_traps_result.count,\n//     };\n\n//     let map_after = [\n//         game.map._data[0].map(|cell| *cell),\n//         game.map._data[1].map(|cell| *cell),\n//         game.map._data[2].map(|cell| *cell),\n//         game.map._data[3].map(|cell| *cell),\n//         game.map._data[4].map(|cell| *cell),\n//         game.map._data[5].map(|cell| *cell),\n//         game.map._data[6].map(|cell| *cell),\n//         game.map._data[7].map(|cell| *cell),\n//         game.map._data[8].map(|cell| *cell),\n//         game.map._data[9].map(|cell| *cell),\n//     ];\n//     assert(map_after.len() == 10);\n//     for i in 0..10 {\n//         assert(map_after[i].len() == 32);\n//     }\n//     let my_chars_after = game.serialize_my_chars();\n//     assert(my_chars_after.success);\n//     let their_chars_after = game.serialize_their_chars();\n//     assert(their_chars_after.success);\n//     let traps_after = serialize_traps(game.get_trap_count() as u8, *game.traps);\n//     let searched_traps_after = serialize_traps(game.get_their_trap_count() as u8, *game.searched_traps);\n\n//     let my_chars = my_chars_after.value;\n//     let their_chars = their_chars_after.value;\n\n//     assert(map_after[2][22] == UNKNOWN_CLASS_TILE);\n\n//     let secret: Field = 1234567890;\n//     let new_hash_array = get_data_hash(secret.to_be_bytes(32), my_chars_after.value.to_be_bytes(32), their_chars.to_be_bytes(32), traps_after.to_be_bytes(32), [\n//         [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, ARCHER, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n//         [WALL, WALL, KNIGHT,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n//         [WALL, EMPTY,MAGE,  EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n//         [WALL, EMPTY,ROGUE,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n//         [WALL, WALL, RITUALIST,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n//         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n//         [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n//     ], searched_traps_after.to_be_bytes(32));\n//     let new_hash = std::field::bytes32_to_field(new_hash_array);\n\n//     assert(new_hash == 0x0716ac88cc4d1abab6ed2c00278573908bc1b360c955eab19e5822c1d107cdcc, f\"hash: {new_hash}, secret: {secret}, my_chars: {my_chars}, their_chars: {their_chars}, traps: {traps_after}, searched_traps: {searched_traps_after}\");\n// }\n\n\n\nstruct Test {\n    a: u8,\n    b: u8,\n}\n\nimpl Test {\n    fn set_a(&mut self, a: u8) {\n        self.a = a;\n    }\n    fn set_b(&mut self, b: u8) {\n        self.b = b;\n    }\n    fn new(a: u8, b: u8) -> Test {\n        Test { a: a, b: b }\n    }\n}\n\nfn t(t: &mut Test, a: pub u8, b: pub u8) {\n    //let t = Test { a: &mut orig_a, b: &mut orig_b };\n\n    t.set_a(a);\n    t.set_b(b);\n\n    assert(t.a == a);\n    assert(t.b == b);\n}\n\nfn main(\n    secret: Field,\n    my_characters: Field,\n    their_characters: Field,\n    actions: [Field; 5],\n    traps: Field,\n    searched_traps: Field, // [u32; HEIGHT],\n    move: pub u32,\n    map_old: [[u8; WIDTH]; HEIGHT],\n    map_new: [[u8; WIDTH]; HEIGHT],\n    received_events: pub [Field; MAX_EVENTS],\n    sending_events: pub [Field; MAX_EVENTS],\n    gamestate_before_hash: pub Field,\n    gamestate_after_hash: pub Field\n) {\n    let old_hash = get_data_hash(secret.to_be_bytes(32), my_characters.to_be_bytes(32), their_characters.to_be_bytes(32), traps.to_be_bytes(32), map_old, searched_traps.to_be_bytes(32));\n    // let old_gamestate_bytes = gamestate_before_hash.to_be_bytes(32);\n    let argh = std::field::bytes32_to_field(old_hash);\n    // assert(old_gamestate_bytes.len() == 32);\n    // for i in 0..32 {\n    //     assert(old_hash[i] == old_gamestate_bytes[i], f\"{argh} != {gamestate_before_hash}\");\n    // }\n    assert(argh == gamestate_before_hash, f\"{argh} != {gamestate_before_hash}\");\n\n    let actor_id = get_actor_from_move(move);\n    assert(actor_id < 5);\n\n    let Result { value: mut game, success: parse_game_success } = Game::build(my_characters, their_characters, traps, searched_traps, map_old);\n    assert(parse_game_success);\n\n    assert(game.won == false);\n    assert(game.lost == false);\n    //assert(game.my_chars[2].get_status() == 2);\n//     // println(game.my_chars[2].get_status());\n\n    for i in 0..MAX_EVENTS {\n        let event = parse_event(received_events[i]);\n        assert(event.process(&mut game));\n    }\n//     //println(game.my_chars[2].get_status());\n\n//     //let mut actor = &mut game.my_chars[actor_id];\n//     // let class = actor.get_class();\n//     // let id = actor.get_id();\n//     // assert(1 == 2,f\"{id} {class}\");\n//     // assert(actor_result.success);\n//     // let mut actor = actor_result.value;\n//     let mut game_events = game.events.map(|event| event);\n//     let mut energy: u8 = 12;\n\n//     //let actor = &mut game.my_chars[actor_id];\n\n\n//     for j in 0..5 {\n//         let split = actions[j].to_be_bytes(32);\n//         let action = split[1];\n//         assert(action < ACTION_COUNT);\n\n//         let current_actor_id = split[2];\n\n//         let current_arg_1 = split[3];\n//         let current_arg_2 = split[4];\n\n//         if (action != WAIT) {\n//             assert(actor_id == current_actor_id, f\"{actor_id} != {current_actor_id}\");\n//             assert(current_actor_id == game.my_chars[current_actor_id].id, game.my_chars[current_actor_id].id);\n//         }\n\n//         let current_class = game.my_chars[current_actor_id].get_class();\n//         println(f\"Current Actor: {current_actor_id} {current_class} {current_arg_1} {current_arg_2} {action}\");\n\n//         let move_to_result = move_to(game.map, game.my_chars[actor_id], &mut energy, split[3], split[4], action == MOVE);\n//         let sneak_result = sneak_to(game.map, game.my_chars[actor_id], &mut energy, split[3], split[4], action == SNEAK);\n//         let mut ec = game.events_count;\n//         // let mut tc = game.trap_count;\n//         let new_trap = Trap { x: split[3], y: split[4], sprung: &mut 0, damage: 64 };\n//             //assert(game.my_chars[actor_id].get_class() == MAGE, game.my_chars[actor_id].get_class());\n//         if action == SNEAK {\n//             println(f\"Sneak\");\n//             // hide: y|x|actor|0\n//             //assert(split[2] == actor_id); // for the most parts, only current actor may do stuff\n//             assert(sneak_result);\n//             // assert(game.add_event(sneak_result.value));\n//             assert(game.my_chars[actor_id].set_status(0));\n//         }\n//         else if action == MOVE {\n//             println(f\"Move to {split[3]} {split[4]}\");\n//             // movey|x|actor|0\n//             //assert(split[2] == actor_id);// for the most parts, only current actor may do stuff\n//             //action_event_result = move_to(game.map, actor, &mut energy, split[3], split[4]);\n//             assert(move_to_result.success);\n//             assert(game.add_event(move_to_result.value));\n//         // game_events[ec & EVENTS_BUFFER_MASK] = move_to_result.value;\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//             assert(game.my_chars[actor_id].set_status(0));\n//         }\n//         else if action == RITUAL {\n//             println(f\"Ritual\");\n//             //assert(split[2] == game.my_chars[actor_id].id); // for the most parts, only current actor may do stuff\n//             assert(game.my_chars[actor_id].get_class() == RITUALIST);\n//             assert(energy == 12);\n//             energy = 0;\n//             if game.my_chars[actor_id].get_status() < 7 {\n//                 (*game.my_chars[actor_id]).status += 1;\n//         // game_events[ec & EVENTS_BUFFER_MASK] = build_std_event(RITUAL, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y());\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//                 assert(game.add_event(build_std_event(RITUAL, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y())));\n//             } else {\n//         // game_events[ec & EVENTS_BUFFER_MASK] = build_std_event(WIN, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y());\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//                 assert(game.add_event(build_std_event(WIN, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y())));\n//             }\n//             assert(game.my_chars[actor_id].set_status(0));\n//         }\n//         else if action == SEARCH {\n//             println(\"Search\");\n//             //assert(split[2] == game.my_chars[actor_id].id);\n//             assert(game.my_chars[actor_id].get_class() == ROGUE);\n//             let x = split[3];\n//             let y = split[4];\n//             assert(x < WIDTH);\n//             assert(y < HEIGHT);\n//             assert(energy >= 6);\n//             let is_neighbor_result = Map::is_neighbor(game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y(), x, y);\n//             assert(is_neighbor_result.success);\n//             assert(is_neighbor_result.value);\n//             // assert(((x == actor.x) & ((y == actor.y + 1) | (y == actor.y - 1))) | ((y == actor.x) & ((x == actor.x + 1) | (x == actor.x - 1))));\n//             // assert(game.add_event(build_std_event(NO_EVENT, 0, 0, 0)));\n//             energy -= 6;\n//             assert(game.my_chars[actor_id].set_status(0));\n//         }\n//         else if action == CAST_FIREBALL {\n//             println(\"Cast Fireball\");\n//            // assert(split[2] == game.my_chars[actor_id].id);// for the most parts, only current actor may do stuff\n//             assert((*game.my_chars[actor_id]).get_class() == MAGE, game.my_chars[actor_id].class);\n//             //assert(current_class == MAGE);\n//             assert(energy == 12);\n//             // TODO: Validate split = target!\n//             energy = 0;\n//             // assert(game.my_chars[actor_id].get_status() == 2);\n//             if game.my_chars[actor_id].get_status() == 0 {\n//                 //println(\"start cast\");\n//                 assert(game.my_chars[actor_id].set_target(split[3], split[4]));\n//             } else {\n//                 // println(\"continue cast\");\n//                 // println(game.my_chars[actor_id].get_target_x());\n//                 println(game.my_chars[actor_id].get_target_y());\n//                 // println(split[3]);\n//                 println(split[4]);\n//                 assert(game.my_chars[actor_id].get_target_x() == split[3]);\n//                 assert(game.my_chars[actor_id].get_target_y() == split[4]);\n//             }\n\n//                 // println(actor_id);\n//                 // println(game.my_chars[actor_id].get_status());\n//             if game.my_chars[actor_id].get_status() < 2 {\n//                 (*game.my_chars[actor_id]).status += 1;\n//         // game_events[ec & EVENTS_BUFFER_MASK] = build_std_event(SEE_CAST, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y());\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//                 assert(game.add_event(build_std_event(SEE_CAST, game.my_chars[actor_id].id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y())));\n//             } else {\n//         game_events[ec & EVENTS_BUFFER_MASK] = build_subtype_value_event(RECEIVE_ATTACK, actor_id, split[3], split[4], 48, ATTACK_FIREBALL);\n//         // assert(ec == 0);\n//         // assert(game_events[0] ==0);\n//             assert(game_events[0] != 0);\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//                 assert(game.add_event(build_subtype_value_event(RECEIVE_ATTACK, actor_id, game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y(), 48, ATTACK_FIREBALL)));\n//             }\n//         }\n//         else if action == SET_TRAP {\n//             println(\"Set Trap\");\n//             //assert(split[2] == game.my_chars[actor_id].id);\n//             assert(game.my_chars[actor_id].set_status(0));\n//             assert(game.add_my_trap(new_trap)); // TODO: add more trap types ... for now all do 64 damage\n\n//             assert(MAX_TRAPS <= TRAPS_BUFFER_SIZE);\n//             // game.traps[tc & TRAPS_BUFFER_MASK] = new_trap;/////////TODO: no idea how to make compiler accept this\n//             // tc += 1;\n//             // *game.trap_count = tc;\n            \n//             //let mut tile = TRAP;\n//             // assert(tc < MAX_TRAPS & game.map.set(new_trap.x, new_trap.y, tile));\n//             // if my_traps.len() >= 10 {\n//             //     let (_popped, rest) = my_traps.pop_front();\n//             //     my_traps = rest.push_back(Trap { x: split[3], y: split[4]});\n//             // }\n//         }\n//         else if action == ATTACK {\n//             println(\"Attack\");\n//             //assert(split[2] == game.my_chars[actor_id].id);\n//             if game.my_chars[actor_id].get_class() == ARCHER {\n//                 assert(game.my_chars[actor_id].get_status() == 1);\n//                 assert(game.add_event(build_subtype_value_event(RECEIVE_ATTACK, actor_id, split[3], split[4], game.my_chars[actor_id].damage, ATTACK_RANGED)));\n//         // game_events[ec & EVENTS_BUFFER_MASK] = build_subtype_value_event(RECEIVE_ATTACK, actor_id, split[3], split[4], game.my_chars[actor_id].damage, ATTACK_RANGED);\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//             } else {\n//                 let is_neighbor_result = Map::is_neighbor(game.my_chars[actor_id].get_x(), game.my_chars[actor_id].get_y(), split[3], split[4]);\n//                 assert(is_neighbor_result.success);\n//                 assert(is_neighbor_result.value);\n//                 // assert_neighbor(actor, split[3], split[4]);\n\n//                 assert(game.add_event(build_subtype_value_event(RECEIVE_ATTACK, actor_id, split[3], split[4], game.my_chars[actor_id].damage, ATTACK_MELEE)));\n//         // game_events[ec & EVENTS_BUFFER_MASK] = build_subtype_value_event(RECEIVE_ATTACK, actor_id, split[3], split[4], game.my_chars[actor_id].damage, ATTACK_MELEE);\n//         // assert(ec < MAX_EVENTS);\n//         // ec += 1;\n//         // *game.events_count = ec;\n//                 // let tile_result = game.get_tile(split[3], split[4]);\n//                 // assert(tile_result.success);\n//                 // if (actor.get_class() == KNIGHT) & (tile_result.value == WALL) {\n//                 //     assert(game.set_tile(split[3], split[4], EMPTY));\n//                 // }\n//             }\n//             assert(game.my_chars[actor_id].set_status(0));\n//         }\n//     //     else if action == DRAW {\n//     //         assert(split[2] == actor.id);\n//     //         assert(actor.get_class() == ARCHER);\n//     //         assert(actor.set_status(1));\n//     //         assert(game.add_event(build_std_event(SEE_DRAW, actor.id, split[3], split[4])));\n//     //     }\n//     //     // else if action == TRIGGER_TRAP {\n//     //     //     let target = split[2];\n//     //     //     assert(game.add_event(build_value_event(TRIGGERED_TRAP, target, split[3], split[4]));\n//     //     //     i += 1;\n//     //     // }\n//     //     else if action == WAIT {\n//     //         // assert(game.add_event(build_event(NO_EVENT, split[2], 255, 255));\n//     //         assert(actor.set_status(0));\n//     //     }\n//     //     else {\n//     //         assert(1 == 2); // basically, invalid action code\n//     //     }\n//     }\n\n// //     for i in 0..MAX_EVENTS {\n// //         let v0 = sending_events[i];\n// //         let v1 = game_events[i];\n// //         assert(sending_events[i] == game_events[i], f\"{i}: {v0} != {v1}\");\n// //     }\n\n// //     for i in 0..HEIGHT {\n// //         for j in 0..WIDTH {\n// //             let tile_result = game.map.get(j, i);\n// //             assert(tile_result.success);\n// //             assert(map_new[i][j] == tile_result.value);\n// //         }\n// //     }\n// //     // if their_char[0].health + their_char[1].health + their_char[2].health + their_char[3].health + their_char[4].health == 0 {\n// //     //     // won0x04021604300200000000000000000000000000000000000000000000000000\n// //     // }         0x04020216300200000000000000000000000000000000000000000000000000\n// //     let map_after = [\n// //         game.map._data[0].map(|cell| *cell),\n// //         game.map._data[1].map(|cell| *cell),\n// //         game.map._data[2].map(|cell| *cell),\n// //         game.map._data[3].map(|cell| *cell),\n// //         game.map._data[4].map(|cell| *cell),\n// //         game.map._data[5].map(|cell| *cell),\n// //         game.map._data[6].map(|cell| *cell),\n// //         game.map._data[7].map(|cell| *cell),\n// //         game.map._data[8].map(|cell| *cell),\n// //         game.map._data[9].map(|cell| *cell),\n// //     ];\n// //     let my_chars_after = game.serialize_my_chars();\n// //     assert(my_chars_after.success);\n// //     let their_chars_after = game.serialize_their_chars();\n// //     assert(their_chars_after.success);\n// //     let traps_after = serialize_traps(game.get_trap_count() as u8, *game.traps);\n// //     let searched_traps_after = serialize_traps(game.get_their_trap_count() as u8, *game.searched_traps);\n\n// //     let new_hash_bytes = get_data_hash(secret.to_be_bytes(32), my_chars_after.value.to_be_bytes(32), their_chars_after.value.to_be_bytes(32), traps_after.to_be_bytes(32), map_after, searched_traps_after.to_be_bytes(32));\n// //     let new_hash = std::field::bytes32_to_field(new_hash_bytes);\n// //     assert(new_hash == gamestate_after_hash, f\"{new_hash} != {gamestate_after_hash}\");\n// //     // let new_gamestate_bytes = gamestate_after_hash.to_be_bytes(32);\n// //     // assert(new_gamestate_bytes.len() == 32);\n// //     // for i in 0..32 {\n// //     //     assert(new_hash[i] == new_gamestate_bytes[i]);\n// //     // }\n// // }\n\n        let ts: [&mut Test; 2] = [ &mut Test::new(map_new[0][0], map_new[0][1]), &mut Test::new(map_new[1][0], map_new[1][1]) ];\n        t(ts[0], map_new[3][3], map_new[2][2]);\n        assert(ts[0].a == map_new[3][3]);\n}\n\n#[test]\nfn test_main() {\n    main(\n        1234567890,\n        0x2202643f0f008203643f0f00a224643604006205643f0f004206643f0f00,\n        0x1602ff1f0f001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00,\n        [ std::field::bytes32_to_field([0, CAST_FIREBALL, 2, 22, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 0, 0, 0, 0],\n        0x000210020300FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,\n        0x000210020300FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,\n        4,\n        [\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, ARCHER, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,               UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [WALL, WALL, KNIGHT,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [WALL, EMPTY,MAGE,  EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, EMPTY,ROGUE,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, WALL, RITUALIST,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n    ],\n        [\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, ARCHER, 0, 0, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, 0, 0, 0, 0, 0],\n        [WALL, WALL, KNIGHT,WALL, WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [WALL, EMPTY,MAGE,  EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, EMPTY,ROGUE,EMPTY,WALL, 0, 0, WALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     UNKNOWN_CLASS_TILE, 0, WALL, 0, 0, WALL, EMPTY,EMPTY,EMPTY,WALL],\n        [WALL, WALL, RITUALIST,WALL, WALL, 0, 0, EMPTY,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNKNOWN_CLASS_TILE, 0, EMPTY,0, 0, WALL, WALL, EMPTY,WALL, WALL],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WATER, WATER, WATER, 0, 0, 0, 0, 0],\n    ],\n        [0; MAX_EVENTS],\n        [build_subtype_value_event(RECEIVE_ATTACK, 2, 22, 4, 48, ATTACK_FIREBALL), 0, 0, 0, 0, 0, 0, 0],\n        0x26006810f066d34cdabf83fa4c697c6e30f252b866758499ac06a7955b4c234b, //0x0716ac88cc4d1abab6ed2c00278573908bc1b360c955eab19e5822c1d107cdcc,\n        0x0a824dd1c049066a192d49045e50814708070119ff93e13bb3805b1074ccaff6\n    )\n}","path":"/home/andreas/git_repositories/noir/skirmish/src/main.nr"},"55":{"source":"use dep::std;\nuse crate::KNIGHT;\nuse crate::MAGE;\nuse crate::RITUALIST;\nuse crate::ROGUE;\nuse crate::WIDTH;\nuse crate::HEIGHT;\nuse crate::CLASS_COUNT;\nuse crate::STATUS_COUNT;\n\nglobal class_damage = [\n    0, // UNKNOWN_CLASS\n    32, //ARCHER\n    8, // RITUALIST\n    24, // ROGUE\n    40, // KNIGHT\n    16, // MAGE\n];\n\nstruct Coordinates {\n    x: u8,\n    y: u8,\n}\n\nstruct Character {\n    id: u8,\n    // pos: Coordinates,\n    // target: Coordinates,\n    x: u8, // 5 bit\n    y: u8, // 4 bit\n    class: u8, // 3 bit\n    status: u8, // 0 = idle, 1-15 = continuing action => 4 bit\n    health: u8,\n    has_been_seen: u1,\n    target_x: u8,\n    target_y: u8,\n    damage: u8,\n}\n\nimpl Character {\n    pub fn get_id(self) -> u8 {\n        self.id\n    }\n\n    pub fn get_x(self) -> u8 {\n        self.x\n    }\n\n    pub fn get_y(self) -> u8 {\n        self.y\n    }\n\n    pub fn get_class(self) -> u8 {\n        self.class\n    }\n\n    pub fn get_status(self) -> u8 {\n        self.status\n    }\n\n    pub fn get_health(self) -> u8 {\n        self.health\n    }\n\n    pub fn get_has_been_seen(self) -> u1 {\n        self.has_been_seen\n    }\n\n    pub fn get_target_x(self) -> u8 {\n        self.target_x\n    }\n\n    pub fn get_target_y(self) -> u8 {\n        self.target_y\n    }\n\n    pub fn get_energy_per_move(self) -> u8 {\n        if (self.class == KNIGHT) | (self.class == MAGE) | (self.class == RITUALIST) {\n            4\n        } else {\n            3\n        }\n    }\n\n    pub fn can_sneak(self) -> bool {\n        self.class == ROGUE\n    }\n\n    pub fn get_energy_per_sneak(self) -> u8 {\n        if self.can_sneak() {\n            6\n        } else {\n            255\n        }\n    }\n\n    pub fn set_pos(&mut self, x: u8, y: u8) -> bool {\n        let success = ((x < WIDTH) & (y < HEIGHT)) | ((x == 255) | (y == 255));\n        if success {\n            (*self).x = x;\n            (*self).y = y;\n        }\n        success\n    }\n\n    pub fn set_class(&mut self, class: u8) -> bool {\n        let success = (class < crate::CLASS_COUNT) & ((self.class == crate::UNKNOWN_CLASS) | (self.class == class));\n        if success {\n            (*self).class = class;\n        }\n        success\n    }\n\n    pub fn set_status(&mut self, status: u8) -> bool {\n        let success = (status < crate::STATUS_COUNT) & ((self.status == 0) | (status == 0) | (self.status + 1 == status));\n        if success {\n            (*self).status = status;\n        }\n        success\n    }\n\n    pub fn set_health(&mut self, health: u8) -> bool {\n        (*self).health = health;\n        true\n    }\n\n    pub fn set_has_been_seen(&mut self, has_been_seen: u1) -> bool {\n        let success = (self.has_been_seen == has_been_seen) | (self.has_been_seen == 0);\n        if success {\n            (*self).has_been_seen = has_been_seen;\n        }\n        success\n    }\n\n    pub fn set_target(&mut self, target_x: u8, target_y: u8) -> bool {\n        let success = ((target_x < WIDTH) & (target_y < HEIGHT)) | ((target_x == 255) & (target_y == 255));\n        if success {\n            (*self).target_x = target_x;\n            (*self).target_y = target_y;\n        }\n        success\n    }\n\n    pub fn is_valid(self) -> bool {\n        ((self.x < WIDTH) & (self.y < HEIGHT)) | ((self.x == 255) & (self.y == 255)) &\n        ((self.class < CLASS_COUNT) & (self.status < STATUS_COUNT)) &\n        ((self.target_x < WIDTH) & (self.target_y < HEIGHT)) | ((self.target_x == 255) & (self.target_y == 255))\n    }\n\n    pub fn has_known_pos(self) -> u8 {\n        if (self.x != 255) & (self.y != 255) {\n            1\n        } else {\n            0\n        }\n    }\n\n    pub fn has_known_target(self) -> u8 {\n        if (self.target_x != 255) & (self.target_y != 255) {\n            1\n        } else {\n            0\n        }\n    }\n\n    pub fn serialize(self) -> crate::Result<[u8; 6]> {\n        let is_valid = self.is_valid();\n        let has_known_pos = self.has_known_pos();\n        let has_known_target = self.has_known_target();\n        let packed_x = self.x | (self.class << 5);\n        let packed_y = self.y | (self.status << 4);\n        let packed_target_x = (self.target_x & 31) | (has_known_pos << 5) | (has_known_target << 6);\n        let packed_target_y = self.target_y & 15;\n        crate::Result {\n            value: [packed_x, packed_y, self.health, packed_target_x, packed_target_y, 0],\n            success: is_valid\n        }\n    }\n\n    pub fn create_character(id: u8, x: u8, y: u8, class: u8) -> crate::Result<Character> {\n        // let mut xx = x;\n        // let mut yy = y;\n        // let mut cc = class;\n        let c = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            status: 0,\n            health: 0,\n            has_been_seen: 0,\n            target_x: 255,\n            target_y: 255,\n            damage: class_damage[class],\n        };\n        crate::Result {\n            value: c,\n            success: c.is_valid()\n        }\n    }\n\n    pub fn parse_character(id: u8, data: Field) -> crate::Result<Character> {\n        // these asserts could be disabled for production\n        assert(WIDTH <= 32);\n        assert(HEIGHT <= 16);\n        assert(CLASS_COUNT <= 8);\n        assert(STATUS_COUNT <= 16);\n\n        let split = data.to_be_bytes(32);\n        let x_packed = split[2 + id * 6]; // 5 bit x, 3 bit class\n        let y_packed = split[2 + id * 6 + 1]; // 4 bit y, 4 bit status\n        let target_x_packed = split[2 + id * 6 + 3]; // 5 bit target x, 1 bit visible, 1 bit has target, 1 bit unused\n        let target_y_packed = split[2 + id * 6 + 4]; // 4 bit target y, 4 bit unused\n        // one byte left for future use\n\n        let is_visible = ((target_x_packed >> 5) & 1) as u1;\n\n        let x = x_packed & 31;\n        let y = y_packed & 15;\n        let class = (x_packed >> 5) & 7;\n        let status = (y_packed >> 4) & 15;\n        let health = split[2 + id * 6 + 2];\n        let target_x = target_x_packed & 31;\n        let target_y = target_y_packed & 15;\n\n        let mut result = Character {\n            id: id,\n            x: x,\n            y: y,\n            class: class,\n            status: status,\n            health: health,\n            has_been_seen: is_visible, // TODO \n            target_x: target_x,\n            target_y: target_y,\n            damage: class_damage[class],\n        };\n\n        let mut success = true;\n        let has_target = (target_x_packed >> 5) & 1;\n        if has_target != 1 {\n            success &= result.set_target(255, 255);\n        }\n\n        // if is_visible != 1 {\n        //     success &= result.set_pos(255, 255);\n        // }\n        if result.get_health() == 255 {\n            success &= (is_visible != 1);\n            // result.set_pos(255, 255);\n            // assert(result.x == 255);\n            // assert(result.y == 255);\n        } /*else {\n            assert((result.x < crate::WIDTH) | (result.x == 255));\n            assert((result.y < crate::HEIGHT) | (result.y == 255));\n        }*/\n        success &= result.is_valid();\n        crate::Result {\n            value: result,\n            success: success\n        }\n    }\n}\n\npub fn get_test_my_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    // let mut xx = x;\n    // let mut yy = y;\n    // let mut cc = class;\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        status: 0,\n        health: 100,\n        has_been_seen: 0,\n        target_x: 255,\n        target_y: 255,\n        damage: class_damage[class],\n    }\n}\n\npub fn get_test_their_character(id: u8, x: u8, y: u8, class: u8) -> Character {\n    assert(id < 5);\n    assert(class < CLASS_COUNT);\n    assert(x < WIDTH);\n    assert(y < HEIGHT);\n\n    // let mut xx = x;\n    // let mut yy = y;\n    // let mut cc = class;\n\n    Character {\n        id: id,\n        x: x,\n        y: y,\n        class: class,\n        status: 0,\n        health: 255,\n        has_been_seen: 0,\n        target_x: 255,\n        target_y: 255,\n        damage: class_damage[class],\n    }\n}\n\n#[test]\nfn test_serialize_character() {\n    let mut character = Character {\n        id: 4,\n        x: 21,\n        y: 9,\n        class: 5,\n        status: 9,\n        health: 129,\n        has_been_seen: 0,\n        target_x: 31,\n        target_y: 15,\n        damage: class_damage[0],\n    };\n    let field_result = character.serialize();\n    assert(field_result.success);\n    let field = field_result.value;\n    assert(field[0] == (21 | (5 << 5)));\n    assert(field[1] == (9 | (9 << 4)));\n    assert(field[2] == 129);\n    assert(field[3] == 127);\n    assert(field[4] == 15);\n    assert(field[5] == 0);\n\n    assert(character.set_pos(1, 1));\n    assert(character.set_status(0));\n    assert(character.set_status(1));\n    assert(character.set_health(1));\n    assert(character.set_has_been_seen(1));\n    assert(character.set_target(255, 255));\n    let field1_result = character.serialize();\n    assert(field1_result.success);\n    let field1 = field1_result.value;\n    assert(field1[0] == (1 | (5 << 5)));\n    assert(field1[1] == (1 | (1 << 4)));\n    assert(field1[2] == 1);\n    assert(field1[3] == 63);\n    assert(field1[4] == 15);\n    assert(field1[5] == 0);\n}\n\n#[test]\nfn test_parse_character() {\n    let data_array: [u8; 32] = [\n        0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n        255 as u8, 255 as u8, 255 as u8, 255 as u8, 255 as u8, 255 as u8,\n        181 as u8, 153 as u8, 129 as u8, 127 as u8, 15 as u8, 0 as u8,\n        0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8, 0 as u8,\n    ];\n    let data: Field = std::field::bytes32_to_field(data_array);\n    println(data);\n    println(\"hallo\"); // 0xffffffffffffb599811f0f000000000000000000 != \n                      // 0xffffffffffff b599811f0f00 000000000000 0000000000\n    assert(data == 0xffffffffffffb599817f0f00000000000000, f\"Failed assumption: data: {data} != 0xffffffffffffb599817f0f000000000000000000\");\n    let character_result = Character::parse_character(3, data);\n    assert(character_result.success);\n    let character = character_result.value;\n    assert(character.get_id() == 3);\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 9);\n    assert(character.get_class() == 5);\n    assert(character.get_status() == 9);\n    assert(character.get_health() == 129);\n    assert(character.get_has_been_seen() == 1);\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 15);\n\n    let character_max_result = Character::parse_character(2, data);\n    assert(!character_max_result.success); // yep this one should fail!\n    let character_max = character_max_result.value;\n    assert(character_max.get_id() == 2);\n    assert(character_max.get_x() == 31);\n    assert(character_max.get_y() == 15);\n    assert(character_max.get_class() == 7);\n    assert(character_max.get_status() == 15);\n    assert(character_max.get_health() == 255);\n    assert(character_max.get_has_been_seen() == 1);\n    assert(character_max.get_target_x() == 31);\n    assert(character_max.get_target_y() == 15);\n\n    let character_min_result = Character::parse_character(0, data);\n    assert(character_min_result.success);\n    let character_min = character_min_result.value;\n    assert(character_min.get_id() == 0);\n    assert(character_min.get_x() == 0);\n    assert(character_min.get_y() == 0);\n    assert(character_min.get_class() == 0);\n    assert(character_min.get_status() == 0);\n    assert(character_min.get_health() == 0);\n    assert(character_min.get_has_been_seen() == 0);\n    assert(character_min.get_target_x() == 255);\n    assert(character_min.get_target_y() == 255);\n}\n\n#[test]\nfn test_parse_character_as_in_game() {\n    let data: Field = 0x1602ff1f0f001603ff1f0f001604ff1f0f001605ff1f0f001606ff1f0f00;\n    let character_result = Character::parse_character(0, data);\n    assert(character_result.success);\n    let character = character_result.value;\n    assert(character.get_id() == 0);\n    assert(character.get_x() == 22, character.get_x());\n    assert(character.get_y() == 2, character.get_y());\n    assert(character.get_class() == 0, character.get_class());\n    assert(character.get_status() == 0, character.get_status());\n    assert(character.get_health() == 255);\n    assert(character.get_has_been_seen() == 0);\n    assert(character.get_target_x() == 255);\n    assert(character.get_target_y() == 255);\n}\n\n#[test]\nfn test_character_setters() {\n    let mut class = ROGUE;\n    let mut character = &mut Character {\n        id: 4,\n        x: 21,\n        y: 9,\n        class: class,\n        status: 9,\n        health: 129,\n        has_been_seen: 0,\n        target_x: 31,\n        target_y: 15,\n        damage: class_damage[class],\n    };\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 9);\n    assert(character.has_known_pos() == 1);\n    assert(character.set_pos(21, 8));\n    assert(character.get_x() == 21);\n    assert(character.get_y() == 8);\n    assert(character.has_known_pos() == 1);\n    assert(character.set_pos(255, 255));\n    assert(character.get_x() == 255);\n    assert(character.get_y() == 255);\n    assert(character.has_known_pos() == 0);\n\n    assert(character.get_class() == ROGUE);\n    assert(character.can_sneak());\n    assert(character.get_energy_per_sneak() == 6);\n    assert(character.get_energy_per_move() == 3);\n    assert(!character.set_class(KNIGHT));\n    (*character).class = crate::UNKNOWN_CLASS;\n    assert(character.set_class(KNIGHT));\n    assert(character.get_class() == KNIGHT);\n    assert(!character.can_sneak());\n    assert(character.get_energy_per_sneak() == 255);\n    assert(character.get_energy_per_move() == 4);\n\n    assert(character.get_status() == 9);\n    assert(character.set_status(10));\n    assert(character.get_status() == 10);\n    assert(!character.set_status(8));\n    assert(character.get_status() == 10);\n\n    assert(character.get_health() == 129);\n    assert(character.set_health(130));\n    assert(character.get_health() == 130);\n\n    assert(character.get_has_been_seen() == 0);\n    assert(character.set_has_been_seen(1));\n    assert(character.get_has_been_seen() == 1);\n    assert(character.set_has_been_seen(1));\n    assert(character.get_has_been_seen() == 1);\n    assert(!character.set_has_been_seen(0));\n    assert(character.get_has_been_seen() == 1);\n\n    assert(character.get_target_x() == 31);\n    assert(character.get_target_y() == 15);\n    assert(character.has_known_target() == 1);\n    assert(character.set_target(1, 1));\n    assert(character.get_target_x() == 1);\n    assert(character.get_target_y() == 1);\n    assert(character.has_known_target() == 1);\n    assert(character.set_target(255, 255));\n    assert(character.get_target_x() == 255);\n    assert(character.get_target_y() == 255);\n    assert(character.has_known_target() == 0);\n}\n\n\n// //crate globals;\n// use crate::globals;\n\n// use globals::get_max_width as max_width;\n// use globals::get_max_height as max_height;\n// use globals::get_class_count as class_count;\n// use globals::get_status_count as status_count;\n// use globals::get_unknown_class as unknown_class;\n\n// struct CharacterData {\n//     id: u8,\n//     x: u8, // 5 bit\n//     y: u8, // 4 bit\n//     class: u8, // 3 bit\n//     status: u8, // 0 = idle, 1-15 = continuing action => 4 bit\n//     health: u8,\n//     has_been_seen: u1,\n//     target_x: u8,\n//     target_y: u8\n// }\n\n// trait Character {\n//     fn get_id(self) -> u8;\n//     fn get_x(self) -> u8;\n//     fn get_y(self) -> u8;\n//     fn get_class(self) -> u8;\n//     fn get_status(self) -> u8;\n//     fn get_health(self) -> u8;\n//     fn get_has_been_seen(self) -> u1;\n//     fn get_target_x(self) -> u8;\n//     fn get_target_y(self) -> u8;\n//     fn set_pos(&mut self, x: u8, y: u8);\n//     fn set_class(&mut self, class: u8);\n//     fn set_status(&mut self, status: u8);\n//     fn set_health(&mut self, health: u8);\n//     fn set_has_been_seen(&mut self, has_been_seen: u1);\n//     fn set_target(&mut self, target_x: u8, target_y: u8);\n\n//     fn serialize(self) -> [u8; 6] {\n//         let packed_x = self.x | (self.class << 5);\n//         let packed_y = self.y | (self.status << 4);\n//         let packed_target_x = self.target_x;\n//         let packed_target_y = self.target_y;\n//         [packed_x, packed_y, self.health, packed_target_x, packed_target_y, 0]\n//     }\n// }\n\n// impl Character for CharacterData {\n//     fn get_id(self) -> u8 {\n//         self.id\n//     }\n\n//     fn get_x(self) -> u8 {\n//         self.x\n//     }\n\n//     fn get_y(self) -> u8 {\n//         self.y\n//     }\n\n//     fn get_class(self) -> u8 {\n//         self.class\n//     }\n\n//     fn get_status(self) -> u8 {\n//         self.status\n//     }\n\n//     fn get_health(self) -> u8 {\n//         self.health\n//     }\n\n//     fn get_has_been_seen(self) -> u1 {\n//         self.has_been_seen\n//     }\n\n//     fn get_target_x(self) -> u8 {\n//         self.target_x\n//     }\n\n//     fn get_target_y(self) -> u8 {\n//         self.target_y\n//     }\n\n//     fn set_pos(&mut self, x: u8, y: u8) {\n//         assert(((x < max_width()) & (y < max_height())) | ((x == 255) & (y == 255)));\n//         self.x = x;\n//         self.y = y;\n//     }\n\n//     fn set_class(&mut self, class: u8) {\n//         assert(class < class_count());\n//         assert((class == self.class) | (self.class == unknown_class()));\n//         self.class = class;\n//     }\n\n//     fn set_status(&mut self, status: u8) {\n//         assert(status < status_count());\n//         self.status = status;\n//     }\n\n//     fn set_health(&mut self, health: u8) {\n//         self.health = health;\n//     }\n\n//     fn set_has_been_seen(&mut self, has_been_seen: u1) {\n//         if (self.has_been_seen != has_been_seen) {\n//             assert(self.has_been_seen == 0);\n//             self.has_been_seen = has_been_seen;\n//         }\n//     }\n\n//     fn set_target(&mut self, target_x: u8, target_y: u8) {\n//         assert(((target_x < max_width()) & (target_y < max_height())) | ((target_x == 255) & (target_y == 255)));\n//         self.target_x = target_x;\n//         self.target_y = target_y;\n//     }\n// }\n\n// pub fn create_character(id: u8, x: u8, y: u8, class: u8)-> impl Character {\n//     assert((x < max_width()) & (y < max_height()));\n//     assert(class < class_count());\n//     CharacterData {\n//         id: id,\n//         x: x,\n//         y: y,\n//         class: class,\n//         status: 0,\n//         health: 0,\n//         has_been_seen: 0,\n//         target_x: 255,\n//         target_y: 255\n//     }\n// }\n\n// pub fn parse_character(id: u8, data: Field) -> impl Character {\n//     // these asserts could be disabled for production\n//     assert(max_width() <= 32 as u8);\n//     assert(max_height() <= 16);\n//     assert(class_count() <= 8);\n//     assert(status_count() <= 16);\n\n//     let split = data.to_be_bytes(32);\n//     let x_packed = split[id * 6]; // 5 bit x, 3 bit class\n//     let y_packed = split[id * 6 + 1]; // 4 bit y, 4 bit status\n//     let target_x_packed = split[id * 6 + 3]; // 5 bit target x, 3 bit unused\n//     let target_y_packed = split[id * 6 + 4]; // 4 bit target y, 4 bit unused\n//     // one byte left for future use\n\n//     let result = CharacterData {\n//         id: id,\n//         x: x_packed & 31,\n//         y: y_packed & 15,\n//         class: (x_packed >> 5) & 7,\n//         status: (y_packed >> 4) & 15,\n//         health: split[id * 6 + 2],\n//         has_been_seen: 0,\n//         target_x: target_x_packed & 31,\n//         target_y: target_y_packed & 15\n//     };\n//     if result.health == 255 {\n//         assert(result.x == 255);\n//         assert(result.y == 255);\n//     } else {\n//         assert((result.x < max_width()) | (result.x == 255));\n//         assert((result.y < max_height()) | (result.y == 255));\n//     }\n//     result\n// }\n\n// #[test]\n// fn test_serialize_character() {\n//     let character = CharacterData {\n//         id: 4,\n//         x: 21,\n//         y: 9,\n//         class: 5,\n//         status: 9,\n//         health: 129,\n//         has_been_seen: 0,\n//         target_x: 31,\n//         target_y: 15\n//     };\n//     let field = character.serialize();\n//     assert(field[0] == (21 | (5 << 5)));\n//     assert(field[1] == (9 | (9 << 4)));\n//     assert(field[2] == 129);\n//     assert(field[3] == 31);\n//     assert(field[4] == 15);\n//     assert(field[5] == 0);\n// }\n\n// #[test]\n// fn test_parse_character() {}","path":"/home/andreas/git_repositories/noir/skirmish/src/character.nr"},"56":{"source":"use crate::MAX_TRAPS;\nuse crate::TRAPS_BUFFER_SIZE;\nuse crate::WIDTH;\nuse crate::HEIGHT;\nuse dep::std;\n\nstruct Trap {\n    x: u8, // 5 bits + 1 bit for sprung + 1 bits for damage / 8, 1 bit reserved (for end detection!)\n    y: u8, // 4 bits + 4 bit damage / 16\n    sprung: &mut u8,\n    damage: u8,\n}\n\nstruct ParseTrapResult {\n    success: bool,\n    value: [Trap; TRAPS_BUFFER_SIZE],\n    count: u64,\n}\n\npub fn parse_traps(data: Field) -> ParseTrapResult {\n    let d = data.to_be_bytes(32);\n    assert(d.len() == 32);\n    let mut success = true;\n    let mut result = [Trap {\n        x: 255,\n        y: 255,\n        sprung: &mut 1,\n        damage: 0\n    }; TRAPS_BUFFER_SIZE];\n    let mut found_end = false;\n    let mut count = 0 as u64;\n    let should_count = d[1] as u64;\n    let mut sprung_buffer = [&mut 0; TRAPS_BUFFER_SIZE];\n                // assert(success == false, f\"fail: {data}\");\n    for i in 0..MAX_TRAPS {\n        let packed_x = d[2 + i * 2];\n        let packed_y = d[2 + i * 2 + 1];\n        *sprung_buffer[i] = ((packed_x >> 5) & 1);\n        result[i] = Trap {\n            x: packed_x & 31,\n            y: packed_y & 15,\n            sprung: sprung_buffer[i],\n            damage: (packed_y & 0xf0) | (((packed_x >> 6) & 1) << 3),\n        };\n        found_end |= (packed_x == 255) & (packed_y == 255);\n        success &= found_end | ((result[i].x < WIDTH) & (result[i].y < HEIGHT));\n        if !found_end {\n            count += 1;\n        }\n        \n        // if (found_end == 0) & (packed_x != 255) & (packed_y != 255) {\n        //     let x = packed_x & 31;\n        //     let y = packed_y & 15;\n        //     if (x >= WIDTH) | (y >= HEIGHT) {\n        //         success = false;\n        //         // assert(success, f\"fail: {i}: {x}, {y} of {data}\");\n        //     };\n        //     result[i] = Trap {\n        //         x: x,\n        //         y: y,\n        //         sprung: sprung_buffer[i],\n        //         damage: (packed_y & 0xf0) | (((packed_x >> 6) & 1) << 3),\n        //     };\n        //     // (*result[i]).x = x;\n        //     // (*result[i]).y = y;\n        //     // (*result[i]).sprung = ((x >> 5) & 1) as u1;\n        //     // (*result[i]).damage = (y & 0xf0) | (((x >> 6) & 3) << 2);\n        //     count += 1;\n        // } else {\n        //     found_end = 1;\n        // }\n    }\n    ParseTrapResult {\n        success: success & (count == should_count),\n        value: result,\n        count: count,\n    }\n}\n\npub fn serialize_traps(count: u8, traps: [Trap; TRAPS_BUFFER_SIZE]) -> Field {\n    assert(WIDTH <= 32);\n    assert(HEIGHT <= 16);\n    let mut parts = [0x0 as u8; 32];\n    parts[1] = count;\n    for i in 0..MAX_TRAPS {\n        let y: u8 = traps[i].y;\n        //assert((i != 15) | (y == 5), f\"fail: {i}: {y}\");\n        parts[2 + i * 2] = (traps[i].x & 0x1f) | ((*traps[i].sprung) << 5) | (((traps[i].damage >> 3) & 1) << 6);\n        parts[2 + i * 2 + 1] = y | (traps[i].damage & 0xf0 as u8);\n    }\n    std::field::bytes32_to_field(parts)\n}\n\n#[test]\nfn test_parse_traps() {\n    //       0x0039 652c a0ae c3ce f481 7ac5 642f 5788 18da 39c1 77df 2b3f a5be 22da 8ff2 5000\n    //       0x6102 0212 6312 0422 2022 0632 6732 0642 6842 0a52 6b52 0c62 2d82 0e02 6ff2 5005\n    let nr = 0x000210020300FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;// 0xFF00030210; //255; //1002055755;\n    let parts = nr.to_be_bytes(32);\n    assert(parts.len() == 32);\n    assert(parts[2] == 16);\n    assert(parts[3] == 2);\n    assert(parts[4] == 3);\n    assert(parts[5] == 0);\n    assert(parts[24] == 255);\n    assert(parts[7] == 255);\n\n    let r_result = parse_traps(nr);\n    assert(r_result.count == 2);\n    assert(r_result.success);\n    let r = r_result.value;\n    assert(r.len() == TRAPS_BUFFER_SIZE);\n    assert(r[0].x == 16);\n    assert(r[0].y == 2);\n    assert(r[1].x == 3);\n    assert(r[1].y == 0);\n\n    // let ser = serialize_traps(r);\n    // assert(ser == nr);\n}\n\n#[test]\nfn test_serialize_traps() {\n    let traps = [\n        Trap { x: 1, y: 2, sprung: &mut 1, damage: 8 },\n        Trap { x: 2, y: 2, sprung: &mut 0, damage: 16 },\n        Trap { x: 3, y: 2, sprung: &mut 1, damage: 24 },\n        Trap { x: 4, y: 2, sprung: &mut 0, damage: 32 },\n        Trap { x: 5, y: 2, sprung: &mut 1, damage: 40 },\n        Trap { x: 6, y: 2, sprung: &mut 0, damage: 48 },\n        Trap { x: 7, y: 2, sprung: &mut 1, damage: 56 },\n        Trap { x: 8, y: 2, sprung: &mut 0, damage: 64 },\n        Trap { x: 9, y: 2, sprung: &mut 1, damage: 72 },\n        Trap { x: 10, y: 2, sprung: &mut 0, damage: 80 },\n        Trap { x: 11, y: 2, sprung: &mut 1, damage: 88 },\n        Trap { x: 13, y: 2, sprung: &mut 1, damage: 128 },\n        Trap { x: 14, y: 2, sprung: &mut 0, damage: 0 },\n        Trap { x: 15, y: 2, sprung: &mut 1, damage: 248 },\n        Trap { x: 16, y: 5, sprung: &mut 0, damage: 8 },\n        Trap { x: 17, y: 5, sprung: &mut 1, damage: 16},\n    ];\n    assert(traps.len() == TRAPS_BUFFER_SIZE);\n    assert(MAX_TRAPS <= TRAPS_BUFFER_SIZE);\n    let r = serialize_traps(MAX_TRAPS as u8, traps);\n    let parts = r.to_be_bytes(32);\n    //assert((16 & 0x1f) | (0 << 5) | (((8 >> 3) & 1) << 6) == 0x50);\n    //assert((2 & 15) | (8 & 0xf0) == 2);\n    //assert(traps[15].y == 5);\n    //assert(r == 0x0039652ca0aec3cef4817ac5642f578818da39c177df2b3fa5be22da8ff25000, f\"serialized {r}\");\n    //assert(r == 0x00006102021263120422202206326732064268420a526b522d820e026ff25005, f\"serialized {r}\");\n    assert(parts.len() == 32);\n\n    //let x: Field = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; //6102021263120422202206326732064268420a526b520c622d820e026ff25005;\n    // assert(x == 0x6102021263120422202206326732064268420a526b520c622d820e026ff25005);\n    let parsed = parse_traps(r);\n    assert(parsed.success);\n    assert(parsed.count == MAX_TRAPS);\n    let p = parsed.value;\n    for i in 0..MAX_TRAPS {\n        assert(p[i].x == traps[i].x);\n        assert(p[i].y == traps[i].y);\n        let should_sprung = *traps[i].sprung;\n        let should_damage = traps[i].damage;\n        let sprung = *p[i].sprung;\n        let damage = p[i].damage;\n        let sprung_data = parts[2 + i * 2];\n        let damage_data = parts[2 + i * 2 + 1];\n        let sprung_calc = ((sprung_data >> 5) & 1);\n        let damage_calc = (damage_data & 0xf0) | (((sprung_data >> 6) & 1) << 3);\n        assert(sprung == should_sprung, f\"{i}: {sprung} != {should_sprung}: {sprung_data} => {sprung_calc}\");\n        assert(damage == should_damage, f\"{i}: {damage} != {should_damage}: {damage_data} => {damage_calc}\");\n    }\n}","path":"/home/andreas/git_repositories/noir/skirmish/src/trap.nr"}},"names":["main"]}